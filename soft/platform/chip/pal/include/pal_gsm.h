/* Copyright (C) 2016 RDA Technologies Limited and/or its affiliates("RDA").
* All rights reserved.
*
* This software is supplied "AS IS" without any warranties.
* RDA assumes no responsibility or liability for the use of the software,
* conveys no license or title under any patent, copyright, or mask work
* right to the product. RDA reserves the right to make changes in the
* software without notification.  RDA also make no representation or
* warranty that such application will be suitable for the specified use
* without further testing or modification.
*/


#ifndef __PAL_GSM_H__
#define __PAL_GSM_H__


#include "cs_types.h"
#include "chip_id.h"

#include "gsm.h"
#include "sxs_type.h"
#include "sxr_jbsd.h"
#include "pal_imei.h"

extern UINT8 pal_snr_factor_var;
extern UINT8 pal_low_rla_var;
extern UINT16 pal_pll_lock_time;

//======================================================================
/// @defgroup pal_stack_api_general PAL & Stack : general principles
///
/// @par Introduction
/// The Physical Abstraction Layer is a set of control functions
/// designed to allow a generic control of Base Band ASIC (BB) and the
/// RF. Most of these functions must be called from the synchronous
/// domain, those which can be called from the asynchronous domain will
/// be clearly identified. Asynchronous functions may be called from the
/// synchronous domain. The synchronous domain is accessible by Layer
/// One thanks to interrupts generated by the BB.\n
/// Resources described in this document must be understood as resources
/// seen from the Layer One point of view and don't necessarily but may
/// correspond to BB physical resources.
///
/// @par Interrupts
/// For a fine control, three kinds of interrupts are expected by the
/// Layer One:
///     - \b Frame interrupt: occurs once per GSM frame. The generation
///       of frame interrupts may be suspended by L1 for power saving
///       purpose. The frame interrupt occurs at the L1 logical start
///       of the frame but doesn't necessarily correspond to the physical
///       start. The latching of the programmed actions occurs at or
///       before the frame interrupt start position.\n
///     - \b Decode interrupt: occurs when SCH decoding is completed
///       (optional), when normal block decoding is completed (optional)
///       and when USFs are ready during a multi PDCH reception decoding
///       process (mandatory).\n
///     - \b Equalizer results ready: occurs once by frame when all
///       equalization results corresponding to the reception window of
///       the previous frame are ready.
///
/// @par Windows
/// To perform reception or transmission, window objects are used to
/// describe the physical channel to deal with.\n
/// For reception, a window must be understood as an equalization window
/// (possibly followed by a decoding) and for transmission as a
/// modulation window (possibly preceded by an encoding).\n
///
/// The following properties apply for reception and transmission windows:
///     - The total number of window resources is limited.
///     - The life duration of a window is usually less than one frame
///     (one exception exists for the FCH reception window).
///     - The creation of a window is always anticipated by one frame.
///     That means that the control function invoked to create a window
///     is called one frame before the frame physically exists
///     (latched operation).
///     - Two windows cannot overlap (MS of class 1 to 12 only)
///     - Two windows are always separated by a configurable lap of
///     time corresponding to the PLL lock time and/or other hardware
///     setup time.
///     - A window may describe a reception or a transmission on several
///     channels of the same type (case of the GPRS where each PDCH
///     corresponds to one slot) with potentially a gap of one or two
///     slots inside the window itself.
///     - Reception and transmission window use common hardware
///     resources. That why window identification is the same for
///     reception and transmission.\n\n
///
/// The windows combination and identification rules are the following:
///     - The minimum number of windows is usually 3. It may be
///     increased to 4 windows to improve measurement performance.
///     - A window is identified by an index (0 to n where n = 3 or 4).
///     The window index is chosen by L1.
///     - The maximum number of monitoring windows per frame corresponds
///     to the maximum number of windows available.
///     - With the exception of the monitoring, the maximum number of
///     reception windows in a frame may be limited to two.
///     - The maximum number of transmission windows per frame is one.\n
///
/// Only the start position of a window is specified by L1. Except for
/// the FCH windows, it is up to the PAL to determine the exact window
/// duration, anticipation, to open and to close the window at the right
/// positions and to program the useful resources (XCV,ADC...) at the
/// right time. FCH windows management is described specifically.
///
/// @par Reception Buffers
///
/// @par Equalisation :
///     - Monitoring : The number of monitoring equalization buffers
///     corresponds to the maximum number of reception windows.
///     Equalization buffer identification is done with the index used
///     for window identification.
///     - FCH : One FCH equalization buffer is required.
///     - SCH : One or two SCH equalization buffers are required.
///     - Normal Burst : Four equalization buffers are required
///     identified thanks to an index [0..3]. It is assumed that only
///     one normal burst window may be set in a frame. Equalization
///     results of the first burst are stored at index 0. In case of
///     multi-slot reception, equalization results of burst n are
///     stored at index n.\n
///     These results must be preserved at least during the frame
///     following the burst receptions.
///
/// @par FCH Detection :
/// Only one FCH detection result buffer is required.
///
/// @par SCH Decoding :
/// Ideally, two SCH decoding buffers are needed. However, L1 can deal
/// with one buffer with performance loss. Each buffer is identified
/// thanks to an index, range [0..1]
///
/// @par Normal Block decoding :
/// Basically, 5 decoding buffers are needed, one tailored for CS1 only
/// and four able to accommodate any coding scheme from CS1 to CS4.
/// This allows the management of the worse case in GPRS class 10 to 12
/// with an allocation of four PDCH downlink and a PTCCH downlink.\n
/// A buffer is identified by its index [0..4], index 4 is reserved for
/// normal block coding scheme 1 only.\n
/// From the Layer One point of view, buffer index selection doesn't
/// need to be fully random but some flexibility is mandatory.
///
/// @par Reception Buffers
///
/// @par (packet)(Random)Access Channel :
/// One buffer of 11 bits and four buffers corresponding to normal block
/// encoding buffers (see below) are necessary.\n
/// Buffer 0 is used in GSM Access state, for the transmission of RACH
/// bursts, in GPRS Access state, for the transmission of PRACH bursts
/// and in Transfer state for the transmission of PTCCH/U blocks.\n
/// In Transfer state, Normal block encoding buffers 1 to 4 may be used
/// for acknowledgment on PACCH transmission on access burst.
///
/// @par Normal Block encoding :
/// Four encoding buffers for CS1 to CS4 coding scheme are requested
/// corresponding to four transmission buffers. A buffer is identified
/// thanks to its index [1..4] In case of multi-slot transmission, a
/// route information associated to the window will indicate the PAL
/// which transmission buffer is to be sent on which PDCH slot.
///
/// @par Reception gain strategy
///
/// Gain strategy may depend on BB capability. In some circumstances,
/// L1 expects the BB to be able to converge by itself toward a
/// sensible gain command before the beginning of a reception window.
/// That's what is called Automatic Gain Control (AGC).\n
/// Automatic gain control is very useful for monitoring purpose when
/// no power information is available concerning the cells to be
/// monitored. In the case of AGC a significant part of the reception
/// window is dedicated by the BB to that purpose.\n
/// For the reception of FCH, SCH and Normal Bursts, a predictive gain
/// strategy is used. In this case, L1 relies on known cell power
/// information coming from monitoring results to provide a gain command
/// to PAL. Predictive gain control allows a better behavior in fading
/// environment. Gain command is expressed as the power expected on the
/// antenna in dBm absolute value.

//======================================================================
// PAL user configurable parameters
//----------------------------------------------------------------------
// Following parameters could be changed depending on HW evolution

/// This parameter reflects the number of frames required to wake up
/// the Base Band ASIC and the RF after the pal_RfSleep function has
/// been invoked.
#define PAL_RF_WAKE_UP_TIME      0

/// This parameter indicates the number of windows that can be handle
/// in a frame. The minimum value is three (1 Rx, 1 Tx and 1 Mx or
/// 1 Rx and 2 Mx or 3 Mx).\n
/// For performance purpose, one additional monitoring window would be
/// a plus especially in GPRS and in a multi-band context to speed up
/// the initial power measurement.
#define PAL_NB_MAX_WIN_PER_FRAME 5

/// This parameter indicates the number of extra windows that can be handle
/// in a frame.
/// NOTE:
/// 8805/8806/8808 chips support dummy PCH detection by implementing 2
/// extra windows in chip patches. Starting from 8809 chips, there are
/// 7 windows per frame in the nature, and chips do NOT need extra
/// windows any more.
/// However, the extra window definition is still kept here for compatibility
/// so that 8809 and later chips can share the same stack library
/// with previous chips.
#if (CHIP_ASIC_ID == CHIP_ASIC_ID_GALLITE || CHIP_ASIC_ID == CHIP_ASIC_ID_8808) && \
    !defined(CHIP_HAS_EXTRA_WINDOWS)
#define PAL_NB_EXTR_WIN_PER_FRAME 0
#else
#define PAL_NB_EXTR_WIN_PER_FRAME 2
#endif

///This parameter indicates the startdate of PCH burst that L1 can expect PAL_PCH_READY immediately after BCPU finishes the dummy detection
#define PAL_DUMMY_DETECT_QBOF 1300

///This parameter indicates the MAX startdate of PCH burst that BCPU is able to do dummy detect.
/// but if startdate is later than PAL_DUMMY_DETECT_QBOF, the wrap value shall be increased to ensure that L1 can finish all jobs within one logical frame.
#define PAL_DUMMY_DETECT_MAX_QBOF 2500

/// This parameter actually corresponds to the minimum possible time
/// between two RF windows (can be longer than the effective PLL Lock
/// time of the tranceiver).
/// It is expressed in quarter-bit (12/13 us).
/// @todo PAL_PLL_LOCK_TIME should be variable, depending on the RF
///       tranceiver used.
#define PAL_PLL_LOCK_TIME        pal_pll_lock_time

/// This parameter corresponds to the monitoring window duration. It
/// includes the AGC search and the measure itself but doesn't include
/// the PLL lock time.\n This value is expressed in 12/13 us periods.
/// @todo check PAL_MON_DURATION definition and usage in L1
#define PAL_MON_DURATION         496 // (152*4)//(72*4)

/// This parameter corresponds to the monitoring duration including PLL
/// lock time expressed in number of half burst period.\n
/// For example, if the PLL lock time is ?burst and the monitoring
/// duration 1 burst, the value is 2.
#define PAL_MON_HTN_DURATION     2

// Transciever's noise floor
#define PAL_LOW_RLA             pal_low_rla_var


/// This parameter corresponds to the factor used for equalization
/// results weighted average.\n
/// TOf and FOf average must be built with a weighted factor
/// corresponding to the SNR provided with the equalization results.
/// The average is assumed to be reliable when the sum of the SNR
/// reaches #PAL_SNR_FACTOR_THRES.
#define PAL_SNR_FACTOR_THRES     pal_snr_factor_var

#define PAL_WIN_BIT_MAP          0x7l   // 1 bit = half a burst. Represents Win + lock time.
#define PAL_MON_BIT_MAP          0xFl   // 1 bit = half a burst. Represents Win + lock time.

#define PAL_FREQUENCY_STEP       0      // Frequency loop step in Hz

//======================================================================
// Fixed values & Macros : DO NOT CHANGE
//----------------------------------------------------------------------
#define PAL_FN_MAX  2715648
/// 1 bit = half a burst. Represents Win + lock time + TA.
#define PAL_TX_WIN_BIT_MAP (PAL_PLL_LOCK_TIME>(PAL_BURST_DURATION/4)?0x0Fl:0x07l)
/// To be used for operation on non serving cell.
#define PAL_LARGE_WIN_BIT_MAP    0xFl
/// Expressed in quarter bit, normal burst reception time without Pll lock time.
#define PAL_BURST_DURATION 625
/// Expressed in quarter bit.
#define PAL_FRAME_DURATION 5000

#define PAL_FINT_SUSPEND_STOP (0xffff - PAL_RF_WAKE_UP_TIME)

#define PAL_EQU_COMPLETE_EVT SXR_USR_EVT(0)
#define PAL_USF_READY_EVT    SXR_USR_EVT(1)
#define PAL_DEC_COMPLETE_EVT SXR_USR_EVT(2)

typedef enum
{
    PAL_CCH_CHN,
    PAL_PDCH_CHN,
    PAL_TCHF_CHN,
    PAL_TCHH_CHN,
    PAL_FACCH_CHN,
    PAL_CDATA_CHN
} pal_CHANNEL_TYPE_t;


#define PAL_AGC 0xFF

#define PAL_A51 0
#define PAL_A52 1
#define PAL_A53 2

#define PAL_GEA1 0
#define PAL_GEA2 1
#define PAL_GEA3 2

#define PAL_CHANNEL_TYPE_MSK      (1 << 0)
#define PAL_FULL_RATE_CHANNEL     (0 << 0)
#define PAL_HALF_RATE_CHANNEL     (1 << 0)
#define PAL_SUB_CHANNEL_MSK       (1 << 1)
#define PAL_GET_SUB_CHANNEL(m)    ((m & PAL_SUB_CHANNEL_MSK) >> 1)
#define PAL_SET_SUB_CHANNEL(m)    ((m << 1) & PAL_SUB_CHANNEL_MSK)
#define PAL_CHANNEL_MODE_MSK      (3 << 2)
#define PAL_SIGNALIZATION_CHANNEL (0 << 2)
#define PAL_SPEECH_CHANNEL        (1 << 2)
#define PAL_DATA_CHANNEL          (2 << 2)
#define PAL_SPEECH_ALGO_MSK       (3 << 4)
#define PAL_SPEECH_ALGO_FR        (0 << 4)
#define PAL_SPEECH_ALGO_HR        (0 << 4)
#define PAL_SPEECH_ALGO_EFR       (1 << 4)
#define PAL_SPEECH_ALGO_AMR       (2 << 4)
#define PAL_DATA_RATE_MSK         (3 << 6)
#define PAL_2400_BAUDS            (0 << 6)
#define PAL_4800_BAUDS            (1 << 6)
#define PAL_9600_BAUDS            (2 << 6)
#define PAL_14400_BAUDS           (3 << 6)


typedef enum
{
    PAL_CLOSE_A_LOOP    = 1,  ///<  TCH Type A loop.
    PAL_CLOSE_B_LOOP    = 2,  ///<  TCH Type B loop.
    PAL_CLOSE_C_LOOP    = 3,  ///<  TCH Type C loop.
    PAL_CLOSE_D_LOOP    = 4,  ///<  TCH Type D loop.
    PAL_CLOSE_E_LOOP    = 5,  ///<  TCH Type E loop.
    PAL_CLOSE_F_LOOP    = 6,  ///<  TCH Type F loop.
    PAL_SPCH_DECOD_LOOP = 7,  ///<  DAI Test of speech decoder & DTX downlink.
    PAL_SPCH_ENCOD_LOOP = 8,  ///<  DAI Test of speech encoder & DTX uplink.
    PAL_ACOUSTIC_TEST   = 9,  ///<  DAI Test of acoustic device and A/D & D/A.
    PAL_OPEN_LOOP       = 10, ///<  Open the closed loop if any and return to normal operation mode.
    PAL_CLOSE_I_LOOP    = 11  ///<  TCH Type I loop.
} pal_TCH_LOOP_t;

// MUST BE THE SAME AS IN STACK (pal_sim.h file)
// Interrupt cause
#define PAL_SIM_RESET_TIMEOUT     0
#define PAL_SIM_PARITY_ERROR      1
#define PAL_SIM_BAD_TS            2
#define PAL_SIM_ATR_SUCCESS       3
#define PAL_SIM_DMA_SUCCESS       4
#define PAL_SIM_ATR_START        5
#define PAL_SIM_WWT_TIMEOUT        6
#define PAL_SIM_EXTRA_RX        7
#define PAL_SIM_INT_CHK            8



typedef struct
{
    UINT16    T1;
    UINT8     T2;
    UINT8     T3;
} pal_GsmCounters_t;

typedef struct
{
    UINT16    Arfcn;
    INT16    Start;
    UINT8     Gain;
    UINT8     WinIdx;
#ifdef MULTI_BANDWIDE
    UINT8     bw;
#endif

} pal_RxWin_t;

typedef struct
{
    INT16    FOf ;
    INT16    TOf ;
} pal_FchResult_t ;

typedef struct
{
    INT16    FOf ;
    UINT16    Snr ;
    UINT8     Data [4];
    INT8     TOf ;
} pal_SchResult_t ;

typedef struct
{
    UINT8 BufferIdx;
    UINT8 ChannelType;
    UINT8 InterruptReq;
} pal_RxBufferCfg_t;

typedef struct
{
    UINT16    Arfcn;
    INT16    Start;
    INT16    FOf;
    UINT8     Gain;
    UINT8     WinIdx;
    UINT8     BufIdx;
    UINT8     BstIdx;
    UINT8     Tsc;
    UINT8     RxBitMap;
#ifdef MULTI_BANDWIDE
    UINT8     bw;
#endif
} pal_NBurstRxWin_t;

typedef struct
{
    INT16    FOf;
    INT8     TOf;
    UINT8     Snr;
    UINT8     Pwr;
#ifndef __NO_AMR__
    UINT8     SID;  // The burst is part of a SID frame.
#endif
} pal_NBurstResult_t;

typedef struct
{
    UINT8     Bfi;
    UINT8     Cs;
#ifndef __NO_AMR__
    UINT8     SID;
#endif
    UINT8     MeanBEP;
    UINT8     CvBEP;
#ifndef __NO_AMR__
    UINT16    BitTotal;
#endif
    UINT16    BitError;
    UINT16   *Data[2];
} pal_NBlockResult_t;

typedef struct
{
    UINT16    Data;
    UINT8     BufIdx;
    UINT8     Bsic;
    UINT8     Size;
} pal_ABurstDesc_t;

/// Block description structure
typedef struct
{
    UINT8   BufIdx;
    UINT8   Tsc;
    UINT8   Cs;
    UINT8   ChannelType;
    UINT8*  Data;
} pal_NBlockDesc_t;

/// TX Window description structure
typedef struct
{
    UINT16 Arfcn;
    INT16  Start;
    UINT8  RouteMap[4];
    UINT8  TxPower[4];
    UINT8  WinIdx;
    UINT8  BstIdx;
    UINT8  Tsc;
    UINT8  TA;
    UINT8  TxBitMap;
} pal_TxWin_t;

/// AMR Configuration structure
typedef struct
{
    UINT8 Version;            ///< AMR version (set to 1)
    UINT8 NoiseSuppression;   ///< Boolean indicating if the noise suppression is allowed.
    UINT8 StartModeIdx;       ///< Index in  the ACS array of the Initial Codec to be used. When value is 0xFF initial codec selection is done according to 05.09 requirement.
    UINT8 NbActiveCodecSet;   ///< Number of codec in ACS array.
    UINT8 ActiveCodecSet [4]; ///< Array of ACS.
    UINT8 Hysteresis [3];     ///< NbActiveCodecSet -1 valid hysteresis.
    UINT8 Threshold [3];      ///< NbActiveCodecSet -1 valid Threshold.
    UINT8 CMIPhase;
} pal_AMRCfg_t;


/// Possible values in the ACS array of #pal_AMRCfg_t
typedef enum
{
    PAL_AMR_12_2, ///<    12,2 kbit/s codec rate.
    PAL_AMR_10_2, ///<    10,2 kbit/s codec rate.
    PAL_AMR_7_95, ///<    7,95 kbit/s codec rate.
    PAL_AMR_7_40, ///<    7,40 kbit/s codec rate.
    PAL_AMR_6_70, ///<    6,70 kbit/s codec rate.
    PAL_AMR_5_90, ///<    5,90 kbit/s codec rate.
    PAL_AMR_5_15, ///<    5,15 kbit/s codec rate.
    PAL_AMR_4_75  ///<    4,75 kbit/s codec rate.
} pal_AMR_ACS_t;


typedef struct
{
    UINT8  Kc [8];   ///< 64 bits ciphering key
    UINT8  Algo;     ///< Algorithm: #PAL_GEA1, #PAL_GEA2 or PAL_GEA3
    UINT32 Input;    ///< input for the ciphering algorithm as described in GSM 04.64
    UINT8  Direction;///< indicates the direction of the block to be ciphered
    UINT16 Length;   ///< number of bytes contained in the data block.
    /// Pointer to the data block indicating the address of the data to be ciphered.
    /// Ciphered data are written back at the position pointed by the Datablock
    /// pointer
    UINT8* DataBlock;
} pal_GprsCiphering_t;

enum {PAL_MS_TO_SGSN, PAL_SGSN_TO_MS};

// To be used as a bitfield parameter for the stack
#define PAL_GSM900   (1<<GSM_BAND_GSM900)
#define PAL_GSM850   (1<<GSM_BAND_GSM850)
#define PAL_DCS1800  (1<<GSM_BAND_DCS1800)
#define PAL_PCS1900  (1<<GSM_BAND_PCS1900)

#define CS1 GSM_CS1
#define CS2 GSM_CS2
#define CS3 GSM_CS3
#define CS4 GSM_CS4

// PAL initialization type
typedef enum { PAL_INIT_GLOBAL,
               PAL_INIT_SYNCHRO,
               PAL_INIT_ASYNCHRO,
               PAL_INIT_ASYNCHRO_WITH_RESETXCV,
               PAL_INIT_ASYNCHRO_WITH_ONSITE_CALIB
             } PAL_INIT_T;


// IRQ sources
#define PAL_DSP_IRQ         0
#define PAL_FINT_IRQ        1
#define PAL_SIM_IRQ         2

#define PAL_NO_INTERRUPT                0
// FINT Irq Mask
#define PAL_FINT_OCCURED                (1 << 0)

// DSP irq Mask
// N.B.: this enum must match the BCPU mailbox defines
typedef enum
{
    PAL_SCH_DECODING_COMPLETE=1,
    PAL_PCH_READY=2,
    PAL_USF_READY=4,
    PAL_EQUALIZATION_COMPLETE=8,
    PAL_DSP_TASK_COMPLETE=16,
    PAL_DSP_NB_DECODING_COMPLETE=32,
    PAL_CCH_DECODING_COMPLETE=64
} PAL_DSP_IRQ_MASK_T;

// Dummy PCH detection status
typedef enum
{
    PAL_DUMMY_PCH_NOT_DETECTED=0,
    PAL_DUMMY_PCH_A_DETECTED=1,
    PAL_DUMMY_PCH_AB_DETECTED=2,
    PAL_PCH_DECODING_COMPLETE=3,
    PAL_DUMMY_PCH_NO_RESULT=0xFF

} PAL_DUMMY_PCH_RESULT_T;

//======================================================================
/// @defgroup pal_stack_api_params PAL < Stack API Generic Parameters
/// @par Generic parameters used for window description.
/// <TABLE BORDER >
/// <TR>
///     <TH> Parameter Name </TH>
///     <TH> Type </TH>
///     <TH> Definition </TH>
///     <TH> Value Range </TH>
/// </TR>
/// <TR>
///     <TD> Arfcn </TD>
///     <TD> UINT16 </TD>
///     <TD> Absolute Radio Frequency Channel </TD>
///     <TD> [0..1024] </TD>
/// </TR>
/// <TR>
///     <TD> Start </TD>
///     <TD> INT16 </TD>
///     <TD> Start position of the window in the frame, expressed in
///          quarter bits. </TD>
///     <TD> [-16..+4999] </TD>
/// </TR>
/// <TR>
///     <TD> Gain </TD>
///     <TD> UINT8 </TD>
///     <TD> Gain command:
///             - Automatic Gain Control
///             - Predictive gain command </TD>
///     <TD> PAL_AGC \n [|-15dBm|..|-110dBm|] </TD>
/// </TR>
/// <TR>
///     <TD> WinIdx </TD>
///     <TD> UINT8 </TD>
///     <TD> Window resource index to be used. </TD>
///     <TD> [0..3] </TD>
/// </TR>
/// <TR>
///     <TD> BufIdx </TD>
///     <TD> UINT8 </TD>
///     <TD> Transmission or reception buffer resource index to be
///          used. </TD>
///     <TD> [0..4] </TD>
/// </TR>
/// <TR>
///     <TD> BstIdx </TD>
///     <TD> UINT8 </TD>
///     <TD> Burst number in the normal block to be received or
///          transmitted. </TD>
///     <TD> [0..3] </TD>
/// </TR>
/// <TR>
///     <TD> Tsc </TD>
///     <TD> UINT8 </TD>
///     <TD> Training Sequence Code </TD>
///     <TD> [0..7] </TD>
/// </TR>
/// <TR>
///     <TD> Rx/TxBitMap </TD>
///     <TD> UINT8 </TD>
///     <TD> Bitmap describing the timeslot allocation to be
///          considered for the window. When the bit n is set in
///          the bitmap that means that the corresponding slot is
///          active for Rx or Tx. This slot numbering is relative
///          to the Start position. </TD>
///     <TD> [0..0x0F] </TD>
/// </TR>
/// <TR>
///     <TD> RouteMap[4] </TD>
///     <TD> UINT8 </TD>
///     <TD> RouteMap[i] contains the Tx buffer index to be
///          considered for transmission on the occurrence i among
///          the bits set in TxBitMap </TD>
///     <TD> [0..3] </TD>
/// </TR>
/// <TR>
///     <TD> TxPower[4] </TD>
///     <TD> UINT8 </TD>
///     <TD> TxPower [i] contains the Tx power command to be
///          considered for transmission on the occurrence i among
///          the bits set in TxBitMap Value PAL_SAME_TXP indicates that
///          the last Tx power value loaded for the considered timeslot
///          remains valid. </TD>
///     <TD> [0..19] or PAL_SAME_TXP </TD>
/// </TR>
/// </TABLE>
///
/// @par Generic parameters retrieved after equalization.
/// <TABLE BORDER >
/// <TR>
///     <TH> Parameter Name </TH>
///     <TH> Type </TH>
///     <TH> Definition </TH>
///     <TH> Value Range </TH>
/// </TR>
/// <TR>
///     <TD> TOf </TD>
///     <TD> INT8 or INT16 </TD>
///     <TD> Timing offset expressed in ?bit period for SCH and Normal
///          Burst, bit period for FCH.\n For NB and SCH, represents the
///          offset between the expected position of the burst given by
///          the window Start parameter and the real position found by
///          the BB.\n For FCH, represents the offset between the window
///          Start position and the real position found by the BB. </TD>
///     <TD> [-156.. +32767] for FCH\n
///          [-48.. +48] for SCH\n
///          [-16.. +16] for NB </TD>
/// </TR>
/// <TR>
///     <TD> FOf </TD>
///     <TD> INT16 </TD>
///     <TD> Frequency offset expressed in Hertz.\n This field may be an
///          output field or an input field. In case of output it gives
///          the estimated frequency error retrieved during equalization
///          of the received burst.\n In case of input, it gives the
///          estimated frequency error to be taken into account for the
///          equalization of the received burst.\n Implementation of
///          input FOf is optional. </TD>
///     <TD> [-32767.. +32767] </TD>
/// </TR>
/// <TR>
///     <TD> Pwr </TD>
///     <TD> UINT8 </TD>
///     <TD> Power measurement expressed in absolute value of dBm. </TD>
///     <TD> [|-47 dBm|..|-110 dBm|] </TD>
/// </TR>
/// <TR>
///     <TD> Snr </TD>
///     <TD> UINT8 </TD>
///     <TD> Signal to noise ratio. </TD>
///     <TD> [0..16] </TD>
/// </TR>
/// </TABLE>
///
/// @par Generic parameters retrieved after decoding.
/// <TABLE BORDER >
/// <TR>
///     <TH> Parameter Name </TH>
///     <TH> Type </TH>
///     <TH> Definition </TH>
///     <TH> Value Range </TH>
/// </TR>
/// <TR>
///     <TD> Bfi </TD>
///     <TD> BOOL </TD>
///     <TD> Bad Frame Indicator. TRUE when decoding has failed,
///          FALSE when decoding is successful. </TD>
///     <TD> {FALSE, TRUE} </TD>
/// </TR>
/// <TR>
///     <TD> Cs </TD>
///     <TD> UINT8 </TD>
///     <TD> Coding scheme found for normal block. </TD>
///     <TD> {CS1, CS2, CS3, CS4} </TD>
/// </TR>
/// <TR>
///     <TD> BitError </TD>
///     <TD> UINT16 </TD>
///     <TD> Number of recovered bit during decoding. </TD>
///     <TD> [0..TBC] </TD>
/// </TR>
/// </TABLE>
//======================================================================

///@defgroup pal_stack_api_func PAL < Stack API Functions
///@{


//======================================================================
// pal_Open
//----------------------------------------------------------------------
/// Low level initialization. Called early by hal_Open.
//======================================================================
VOID pal_Open (VOID);

//======================================================================
// Initialization : pal_Initialisation
//----------------------------------------------------------------------
/// Asynchronous.\n
/// This function is called to initialize the PAL context and the
/// BaseBand + RF. The Total parameter is set to TRUE for the very first
/// call or when a complete initialization of the PAL and the hardware
/// is expected and allowed.\n
/// In some circumstances, initialization may be partly completed where
/// tones(?) must be preserved, in this case, the parameter Total is
/// set to FALSE.
///
/// @param InitType: init at power up, synchro(L1s) and asynchro(L1a).
/// @param BandMap bitmap indicating on which bands combination PAL is
///                expected to work:
///                   - #PAL_GSM900
///                   - #PAL_GSM850
///                   - #PAL_DCS1800
///                   - #PAL_PCS1900\n
/// Due to radio channel numbering, the band bitmap can include only a
/// single GSM band and a single high band among DCS1800 and PCS1900.
//======================================================================
VOID pal_Initialisation (PAL_INIT_T InitType, UINT8 BandMap);

//======================================================================
// Initialization : Interruption vector
//----------------------------------------------------------------------
/// Asynchronous.\n
/// Used to configure the user interrupt vector for the identified
/// interrupt.
/// The provided handler prototype has a Status bit map as parameter.
/// This Status provides the bit map of the interrupt source.
/// This bit map may be useless for some interrupts.\n
/// As far as the DSP interrupt is concerned the Status may have the
/// following values:
///             - #PAL_SCH_DECODING_COMPLETE
///             - #PAL_PCH_READY
///             - #PAL_USF_READY
///             - #PAL_EQUALIZATION_COMPLETE\n
/// The Equalizer complete interrupt shall be generated on the frame
/// n+1 when all the equalization results corresponding to the
/// receptions that occurred on the frame n are ready.
/// @param interruptId The interrupt identifier is among the following:
///             - #PAL_FINT_IRQ
///             - #PAL_DSP_IRQ
///             - #PAL_SIM_IRQ
/// @param handler pointer to the handler function
//======================================================================
VOID pal_SetUsrVector (UINT8 interruptId, VOID (*handler) (UINT32 status));

//======================================================================
// Initialization : Interruption vector Mask
//----------------------------------------------------------------------
/// Asynchonous.\n
/// This function is used to activate and deactivate interrupt sources.
/// An active bit in the mask bit map means that the interruption is
/// required.
/// @param interruptId The interrupt identifier is among the following:
///             - #PAL_FINT_IRQ
///             - #PAL_DSP_IRQ
///             - #PAL_SIM_IRQ
/// @param mask bitmap enable of the various sources of an interrupt.\n
///             Example:\n Enable Equalization result and USF ready
///             sources on DSP interrupt.\n
///             #pal_SetUsrVectorMsk(#PAL_DSP_IRQ,
///                                  #PAL_EQUALIZATION_COMPLETE |
///                                  #PAL_USF_READY);
//======================================================================
VOID pal_SetUsrVectorMsk (UINT8 interruptId, UINT32 mask);

//======================================================================
// Frame boundaries function : pal_FrameStart
//----------------------------------------------------------------------
/// Must be called by Layer One at the beginning of a new frame (which
/// means at the beginning of the frame interrupt) before invoking any
/// PAL control function in the synchronous domain.
//======================================================================
VOID pal_FrameStart (VOID);

//======================================================================
// Frame boundaries function : pal_FrameEnd
//----------------------------------------------------------------------
/// Called at the end of the L1 logical frame when all the PAL
/// synchronous functions are invoked for the current frame.
//======================================================================
VOID pal_FrameEnd (VOID);

//======================================================================
// Time drift correction
//----------------------------------------------------------------------
/// Function used for correcting small timing drifts during connected
/// mode.
///
/// @param TOf The timing offset expressed in ?bits (12/13 us)
///            corresponding to the timing drift to be compensated
///            by PAL.
//======================================================================
VOID pal_TimeTuning (INT8 TOf);

//======================================================================
// Frequency drift correction
//----------------------------------------------------------------------
/// @param FOf expressed in Hertz and corresponds to the frequency
///            drift to be compensated by PAL.
/// @param Arfcn parameter corresponding to the Absolute Radio
///              Frequency Channel used for the measurement.
///              It is needed to get a relative frequency drift
///              measurement.
//======================================================================
VOID pal_FrequencyTuning (INT32 FOf, UINT16 Arfcn);

//======================================================================
// Time synchronization change
//----------------------------------------------------------------------
/// This function is invoked by L1 when a cell change or a timeslot
/// change occurs. During normal operation, L1 is expected to keep PAL
/// frame position aligned with the first reception burst corresponding
/// to the current MS allocation.
///
/// @param TOf Timing offset corresponding to the distance between the
///            current frame position and the new frame position.
///            It is expressed in quarter bits and is always positive.
//======================================================================
VOID pal_SynchronizationChange (UINT16 TOf);

//======================================================================
// GSM counters setting
//----------------------------------------------------------------------
/// This function is used to provide PAL with the updated set of
/// GSM counters. Counters values are valid for the next frame.
///
/// @param Counters pointer to the counter structure.
//======================================================================
VOID pal_SetGsmCounters (pal_GsmCounters_t *Counters);

VOID pal_RxBufferCfg (pal_RxBufferCfg_t *Cfg);

//======================================================================
// Reception management : Monitoring window
//----------------------------------------------------------------------
/// This function opens a monitoring window on next frame to perform
/// a power measurement.
/// @param Win pointer to the window structure used for monitoring,
///            FCH and SCH reception purpose.
//======================================================================
VOID pal_SetMonRxWin (pal_RxWin_t *Win);

//======================================================================
// Reception management : Monitoring result
//----------------------------------------------------------------------
/// This function retrieves the power measurement result corresponding
/// to the window specified as parameter. The result returned by the
/// function is expressed in absolute value of dBm
/// (range [|-15 dBm|..|-110 dBm|]).
/// Usually called in frame n+2 when pal_SetMonRxWin is called in frame
/// n. Nevertheless, equalizer result interrupt may lead to an earlier
/// call.
///
/// @param Win pointer to the window structure used for monitoring,
///            FCH and SCH reception purpose.
//======================================================================
UINT8 pal_GetMonResult (pal_RxWin_t *Win);

//======================================================================
// Reception management : Interference window
//----------------------------------------------------------------------
/// This function opens an interference window on next frame to perform
/// an interference measurement.  The start position provided must
/// correspond to the beginning of a slot. Measures are done for NbSlots
/// timeslots. Each measure must be done on a maximum of 156 GSM bits
/// (including eventual automatic gain search).
///
/// @param Win pointer to the window structure used for monitoring,
///            FCH and SCH reception purpose.
/// @param NbSlots number of timslots to be measured,
//======================================================================
VOID pal_SetIntRxWin (pal_RxWin_t *Win, UINT8 NbSlots);

//======================================================================
// Reception management : Interference window results
//----------------------------------------------------------------------
/// This function retrieves the interference measurement result for the
/// window specified as parameter. Results are stored in the array
/// IntMeas. The array is indexed with the timeslot number, the timeslot
/// 0 corresponding to the start position provided in the Rx window
/// description.
/// The results are expressed in absolute value of dBm
/// (range [|-47 dBm|..|-110 dBm|]).
/// This function is called in frame n+2 when pal_SetIntRxWin is called
/// in frame n.
///
/// @param Win pointer to the window structure used for monitoring,
///            FCH and SCH reception purpose.
/// @param IntMeas array of power results, indexed with timeslot number.
//======================================================================
VOID pal_GetIntResult (pal_RxWin_t *Win, UINT8 *IntMeas);

//======================================================================
// Reception management : FCCH window opening
//----------------------------------------------------------------------
/// This function opens a FCH detection window on next frame. The window
/// remains open until the Layer One invokes the stop function.
/// Nevertheless, the PAL may close the window by itself as soon as the
/// detection is successful.
///
/// @param Win pointer to the window structure used for monitoring,
///            FCH and SCH reception purpose.
//======================================================================
VOID pal_SetFchRxWin (pal_RxWin_t *Win);

//======================================================================
// Reception management : FCCH window closing
//----------------------------------------------------------------------
/// This function must be called to close a previously opened FCH
/// detection window. The "Stop Position" is expressed in quarter bits
/// and indicates the position in the next frame where the window must
/// end.
///
/// @param StopPosition window end position expressed in quarter bits.
//======================================================================
VOID pal_CloseFchRxWin (UINT16 StopPosition);

//======================================================================
// Reception management : FCCH window results
//----------------------------------------------------------------------
/// This function returns TRUE when FCH detection has been successfully
/// completed and FALSE otherwise. It may be called while the detection
/// window is open or any time after the detection window has been
/// closed, provided that a new detection window has not been opened.
///
/// @param WinIdx index of the FCCH window.
/// @param Res pointer to the FCCH result structure.
//======================================================================
BOOL pal_GetFchResult (UINT8 WinIdx, pal_FchResult_t *Res);

//======================================================================
// Reception management : SCH window
//----------------------------------------------------------------------
/// This function is invoked to open a SCH reception window in the next
/// frame.
///
/// @param Win pointer to the window structure used for monitoring,
///            FCH and SCH reception purpose.
/// @param FOf expected frequency offset for this window (its not
///            mandatory for PAL to compensate for this drift).
//======================================================================
VOID pal_SetSchRxWin (pal_RxWin_t *Win, INT16 FOf);

//======================================================================
// Reception management : SCH window results
//----------------------------------------------------------------------
/// This function retrieves the SCH reception results corresponding to
/// the identified window.  It returns TRUE when SCH has been
/// successfully decoded and FALSE otherwise.
/// The "Data" field in pal_SchResult_t structure corresponds to the
/// SCH decoding data as described in 3GPP 44.018
///
/// @param BufIdx If two reception buffers are available, the buffer
///               index to be used corresponds to the window index
///               parity.
/// @param Res pointer to the SCH result structure.
//======================================================================
BOOL pal_GetSchResult (UINT8 BufIdx, pal_SchResult_t *Res);

//======================================================================
// Reception management : set dummy PCH detection active
/// This function is invoked to enable the dummy PCH detection in idle
/// mode, it sets a palCtx variable that enables the detection on the
/// BCPU and writes the thresholds into the mailbox. This function has
/// to be called before pal_SetNBrxWin().
//----------------------------------------------------------------------
VOID pal_SetDummyPchDetection(UINT8 Thresh_a, UINT8 Thresh_b, INT32 winDate);

//======================================================================
// Reception management : get/clr dummy PCH detection active
/// This function is invoked to get the dummy PCH detection result, it
/// also resets the palCtx variable that enable the detection. This
//function has to be called on the recption of the DSP irq PAL_PCH_READY.
//----------------------------------------------------------------------
PAL_DUMMY_PCH_RESULT_T pal_GetDummyPchDetection(VOID);

//======================================================================
// Reception management : Normal Burst window
//----------------------------------------------------------------------
/// This function is invoked to open a Normal Burst window in the next
/// frame. Decoding is started automatically by the PAL after the
/// reception of the fourth burst (ie when BstIdx is set to 3).
/// In case of multi-slot reception, BufIdx corresponds to the first
/// buffer to be used to store the decoding data of the first active
/// slot in the bitmap. Decoding data of the next active slot are stored
/// in BufIdx + 1 and so on.
///
/// @param Win pointer to normal burst description structure.
//======================================================================
VOID pal_SetNBurstRxWin (pal_NBurstRxWin_t *Win);

//======================================================================
// Reception management : Normal Burst window results
//----------------------------------------------------------------------
/// This function retrieves the normal burst equalization results
/// corresponding to the burst identified by index in the multi-slot
/// windows. Results are written in the structure whose address is given
/// as parameter.\n
/// Called in frame n+2 when pal_SetNBurstWin is called in frame n.
///
/// @param Idx slot index (for multislot windows)
/// @param Arfcn Absolute Radio Frequency Channel
/// @param Res pointer to the Normal Burst result structure.
//======================================================================
VOID pal_GetNBurstResult (UINT8 Idx, UINT16 Arfcn, pal_NBurstResult_t *Res);

//======================================================================
// Reception management : Block result
//----------------------------------------------------------------------
/// This function is used to retrieve the decoding results of the normal
/// block identified by BufIdx.  PAL is expected to dynamically allocate
/// a buffer of the required size to fit the coding scheme found during
/// decoding.\n
/// The buffer size must be increased by BufferOffset bytes and the
/// decoding data must be stored after BufferOffset bytes in the buffer.
/// The buffer address is stored in the pointer Data [0]. If the block
/// has not been successfully decoded, the pointer Data [0] must be set
/// to 0.\n
/// In case of TCH, decoding data are retrieved only if a FACCH has been
/// found and successfully decoded otherwise pointer Data [0] is set to
/// 0.\n
/// The pointer Data [1] must be considered only when a TCH channel is
/// opened in data mode. In this case, a buffer is allocated as
/// described for Data [0] and contains the results of the data block
/// decoding.\n
/// Buffers release is handled by L1 or another layer of the protocol
/// stack.\n
/// The function is called in frame n+2 when pal_SetNBurstWin for fourth
/// burst is called in frame n.
///
/// @param BufIdx Buffer index of the block of interest.
/// @param BufferOffset Output buffer increase in bytes. Decoded data
///                     must be stored after this offset.
/// @param Res pointer to the Block result structure.
//======================================================================
VOID pal_GetNBlockResult (UINT8 BufIdx, UINT8 BufferOffset, pal_NBlockResult_t *Res);

//======================================================================
// Reception management : Uplink State Flags results
//----------------------------------------------------------------------
/// This function is used to retrieve USFs of the last decoded PDCH
/// blocks. It is called in USF ready interrupt. USF ready interrupt
/// must occur in the frame in which the fourth PDCH bursts are received.
/// This interrupt must occur at least 1 ms before the next frame
/// physical boundary to allow L1 to set transmission windows if needed.
/// PAL uses the array of which the address is given as parameter by L1
/// to store the USF values. Positions in the array are indexed with
/// BufIdx.
/// The array has a size of four bytes. When no USF is found in a
/// reception buffer, the corresponding position in the Usf array shall
/// be set to 0xFF.
///
/// @param Usf Array of USF values (indexed by the buffer index).
//======================================================================
VOID pal_GetUsf (UINT8 *Usf);

//======================================================================
// Transmission management : Access Burst Encoding
//----------------------------------------------------------------------
/// This function is used to encode an access burst (RACH, PRACH, PACCH,
/// PTCCH/U) and must be called one frame ahead of the transmission
/// frame with the exception of PACCH transmitted on access burst,
/// for which normal block rules described below apply.\n
/// Except for the PACCH, encoding occurs at the beginning of the frame
/// following the call.\n
/// The data to be encoded is either 8 bit long or 11 bit long.
/// Data size is specified in field Size.
/// Bsic field corresponds to the Base transceiver station identity
/// code (6 bits) as specified in 3GPP 45.002
///
/// @param AB pointer to the access burst description structure.
//======================================================================
VOID pal_ABurstEncoding (pal_ABurstDesc_t *AB);

//======================================================================
// Transmission management : Normal Burst Encoding
//----------------------------------------------------------------------
/// This function is used to encode a normal block (SACCH, SDCCH, FACCH,
/// TCH(data), PDCH, PACCH) and may be called one to three frames ahead
/// of the transmission of the first burst of the block. Encoding occurs
/// at the beginning of the frame in which the first burst of the block
/// must be transmitted.\n
/// The data to be encoded are accessible through pointer Data.
/// The number of bytes to be encoded depends on the coding scheme value
/// Cs.\n
/// The Data buffer belongs to L1 and must not be released by PAL.\n
/// FACCH flag must be considered only when a TCH channel is opened and
/// indicates that the block to be encoded corresponds to a FACCH.\n
/// When a TCH channel is opened, pal_NblockEncoding is not called to
/// encode TCH blocks.
/// It is called only to encode the SACCH blocks, the FACCH blocks and
/// the data blocks when the TCH channel is opened in data mode.
/// The same buffer index must be used for the FACCH and the data block
/// encoding. A different buffer index must be used for the SACCH
/// encoding.
///
/// @param NB pointer to the normal burst description structure.
//======================================================================
VOID pal_NblockEncoding (pal_NBlockDesc_t *NB);

//======================================================================
// Transmission management : TX window
//----------------------------------------------------------------------
/// This function is used to open a transmission window in the next
/// frame. Encoding of relevant data must have been done prior to the
/// call. The type of burst (normal burst or access burst) is determined
/// thanks to the type of data encoded in the buffers identified for
/// each slot by the RouteMap array.\n
/// TA represents the timing advance expressed in quarter bits.
/// Start position doesn't take the timing advance into account.
/// It is up to PAL to anticipate the burst transmission by the timing
/// advance value for normal burst only.
///
/// @param Win pointer to the TX window description structure.
//======================================================================
VOID pal_SetTxWin (pal_TxWin_t *Win);

//======================================================================
// Transmission management : window downsizing
//----------------------------------------------------------------------
/// This function is called when the L1 has to resize shorter the
/// previously programmed multi slot window for the purpose of near cell
/// detection in GPRS transfer mode (i.e. FCCH and SCH windows).\n
/// This function is called only when a collision is detected by the L1.
/// PAL must stop the window identified by WinIdx at the required
/// position identified by StopPos.\n
/// The bursts that would have been transmitted or received are lost.\n
/// Restrictions :
///    - Called only on TX window
///    - Can erase a window completely
///    - Called after Rx and Tx windows programing,
///      but before FCCH/SCH programing
///
/// @param WinIdx Index of the window to be resized.
/// @param StopPos Time at which the window should be stopped.
//======================================================================
VOID pal_WinResize (UINT8 WinIdx, UINT16 StopPos);

//======================================================================
// Ciphering Control : GPRS
//----------------------------------------------------------------------
/// The function pal_GprsCiphering is used in GPRS by the LLC layer to
/// cipher and decipher a block of data.\n
/// The call of the function is blocking. The function shall use the
/// minimum of CPU time.
///
/// @param GprsCiphering pointer to the ciphering description structure.
//======================================================================
VOID pal_GprsCiphering (pal_GprsCiphering_t *GprsCiphering);

//======================================================================
// Ciphering Control : GSM start of ciphering
//----------------------------------------------------------------------
/// This function is used to start GSM ciphering on transmitted bursts
/// and deciphering on received bursts.\n
/// The Algo parameter specifies the ciphering algorithm to be used
/// The "Key" pointer gives access to the array containing the 8-bytes
/// ciphering key.\n
/// To properly achieve the ciphering, the PAL must be given an updated
/// set of GSM counters prior to the call (see #pal_SetGsmCounters).
///
/// @param Algo Algorithm to be used. May take the following values:\n
///     - #PAL_A51
///     - #PAL_A52
/// @param Key Pointer to an input array of 8-bytes.
//======================================================================
VOID pal_StartCiphering (UINT8 Algo, UINT8 *Key);

//======================================================================
// Ciphering Control : GSM stop of ciphering
//----------------------------------------------------------------------
/// This function is used to stop the GSM ciphering.
//======================================================================
VOID pal_StopCiphering (VOID);

//======================================================================
// TCH control : start TCH
//----------------------------------------------------------------------
/// This function is used to set up a traffic channel or to modify a
/// traffic channel configuration.
/// The Mode parameter is a bit map described in the following table.
/// @todo Make a bitmap structure for ChannelMode
///  <TABLE BORDER >
/// <TR>
///     <TH> Bit Number </TH>
///     <TH> Description </TH>
///     <TH> Possible Values </TH>
/// </TR>
/// <TR>
///     <TD> Bit 0 </TD>
///     <TD> Channel Type </TD>
///     <TD> 0: Full rate channel\n
///          1: Half rate channel </TD>
/// </TR>
/// <TR>
///     <TD> Bit 1 </TD>
///     <TD> When channel type is set to half rate,
///          sub channel number. </TD>
///     <TD> {0, 1} </TD>
/// </TR>
/// <TR>
///     <TD> Bit 2 & 3 </TD>
///     <TD> Channel Mode </TD>
///     <TD> 0: Signalization channel\n
///          1: Speech channel\n
///          2: Data Channel </TD>
/// </TR>
/// <TR>
///     <TD> Bit 4 & 5 </TD>
///     <TD> When channel mode is set to speech, speech algorithm. </TD>
///     <TD> 0: FR or HR\n
///          1: EFR or undefined in half rate\n
///          2: FR AMR or HR AMR\n </TD>
/// </TR>
/// <TR>
///     <TD> Bit 6 & 7 </TD>
///     <TD> When channel mode is set to data,
///          this field represents the data rate. </TD>
///     <TD> 0: 2400 bauds\n
///          1: 4800 bauds\n
///          2: 9600 bauds\n
///          3: 14400 bauds\n </TD>
/// </TR>
/// </TABLE>
/// @par AMR Mode
/// Once the AMR speech codec is activated the PAL is expected to handle
/// the associated protocol including the in band signalization
/// (Frequent and RATSCCH) by itself.
///
/// @param Mode TCH type.
/// @param TN Timeslot number. (useless)
/// @param AMRCfg pointer to the AMR configuration structure in case the
///               mode parameter indicates that the AMR speech coding is
///               selected.
//======================================================================
VOID pal_StartTch (UINT8 Mode, UINT8 TN, pal_AMRCfg_t *AMRCfg);

//======================================================================
// TCH control : Change mode
//----------------------------------------------------------------------
/// This function is used to change the Tch Mode. The channel type and
/// the sub channel number are not changed with this function.
/// The AMR configuration is provided only when a new configuration is
/// available.  Otherwise, the pointer is set to null.
///
/// @param Mode Requested Mode (only Channel Mode field is relevant)
/// @param AMRCfg new AMR configuration when applicable (else NULL)
//======================================================================
VOID pal_ChangeTchMode (UINT8 Mode, pal_AMRCfg_t *AMRCfg);

//======================================================================
// TCH control : set test loop
//----------------------------------------------------------------------
/// This function is used to close the required TCH loop. The Mode
/// Parameter may take one of #pal_TCH_LOOP_t values.
///
/// @todo Mode parameter should be typed to pal_TCH_LOOP_t
/// @param Mode TCH Loop Mode
//======================================================================
VOID pal_SetTchLoop (UINT16 Mode);

//======================================================================
// TCH control : stop TCH
//----------------------------------------------------------------------
/// This function is invoked by L1 to notify the end of the traffic
/// channel. The PAL may have to set the audio device in low power
/// consumption mode.
//======================================================================
VOID pal_StopTch (VOID);

//======================================================================
// TCH control : Get current AMR Mode
//----------------------------------------------------------------------
/// Thanks to the RATSCCH protocol, the PAL is likely to modify the AMR
/// configuration initially given to the PAL. This function is used to
/// retrieve the current AMR configuration. It is called by the L1
/// before an assignment or a handover on a new channel to retrieve the
/// current AMR configuration that must be restored in case of
/// reestablishment.\n
/// The retrieved configuration must correspond to the last
/// configuration acknowledged with the RATSCCH protocol.\n
/// The pointer AMRCfg given as parameter provides the address where the
/// current configuration must be copyied by PAL.
///
/// @param AMRCfg pointer to the AMR Config structure to be filled.
//======================================================================
VOID pal_RetrieveCurrentAMRCfg (pal_AMRCfg_t *AMRCfg);

//======================================================================
// TCH control : Enable DTX
//----------------------------------------------------------------------
/// This function is used to give the DTX configuration. When the
/// DtxAllowed parameter is set to TRUE, uplink discontinuous
/// transmission may be used by the MS, when set to FALSE, uplink
/// discontinuous transmission is forbidden.
///
/// @param DtxAllowed TRUE when DTX is allowed, FALSE otherwise.
//======================================================================
VOID pal_SetDtx (BOOL DtxAllowed);

//======================================================================
// TCH control : Get DTX usage
//----------------------------------------------------------------------
/// This function is invoked by L1 at the beginning of a reporting
/// period to know if DTX was used in the previous reporting period.
///
/// @return TRUE if DTX has been used during previous reporting period.
//======================================================================
BOOL pal_GetDtx (VOID);

//======================================================================
// Power Down Management : suspend FINT interrupt
//----------------------------------------------------------------------
/// This function is used by the Layer One to suspend the frame
/// interrupt generation for the required number of frames.\n
/// To decrease the power consumption, the hardware GSM time base should
/// be switched on a low frequency clock base instead of the main VCO.
///
/// @param NbFrames number of frames to be skipped.
///         if NbFrames >= PAL_FINT_SUSPEND_STOP, the frame
///         interrupt is disabled until pal_FintResume() is called.
//======================================================================
VOID pal_FintSuspend (UINT16 NbFrames);

//======================================================================
// Power Down Management : resume FINT interrupt
//----------------------------------------------------------------------
/// Asynchronous.\n
/// FintResume is invoked to achieve a forced wake up and resume the
/// frame interrupt generation earlier than expected.\n
/// No effect when invoked whereas the frame interrupt is not suspended.
//======================================================================
VOID pal_FintResume (VOID);

//======================================================================
// Power Down Management :
//----------------------------------------------------------------------
/// This function is called in the first frame interrupt occurring
/// after a suspension period and returns the number of frame interrupts
/// elapsed during sleep period.
///
/// @return number of skipped frames.
//======================================================================
UINT16 pal_GetElapsedTime (VOID);

//======================================================================
// RF/CLK Management :
//----------------------------------------------------------------------
/// This function could be invoked prior to any PAL RF control functions
/// with a programmable anticipation, typically one frame. The purpose
/// of this function is to wake up all the RF resources that require
/// more than one frame of set up time. If no RF resource requires more
/// than one frame of set up time, wake up can be done in the PAL RF
/// control functions set and this function is useless.
///
/// @todo In our implementation this function is useless
//======================================================================
VOID pal_RfWakeUp (VOID);

//======================================================================
// RF/CLK Management :
//----------------------------------------------------------------------
/// To be invoked to set RF resources in power down.
/// This function may be useless, depending on the anticipation time
/// required for wake up. If one frame is required, sleep mode can be
/// handled by PAL itself.
///
/// @todo In our implementation this function is useless
//======================================================================
VOID pal_RfSleep (VOID);

//======================================================================
// VCO dependent resources management :
//----------------------------------------------------------------------
/// This function is used to notify that the resource identified by its
/// number given as parameter is active and that the VCO cannot be
/// switched off.
///
/// @param ResourceNumber resource number to be flagged as active
/// @todo clarify resource management policy
//======================================================================
VOID pal_ResourceActive (UINT8 ResourceNumber);

//======================================================================
// VCO dependent resources management :
//----------------------------------------------------------------------
/// This function is used to notify that the resource identified by its
/// number given as parameter is inactive.
///
/// @param ResourceNumber resource number to be flagged as inactive
/// @todo clarify resource management policy
//======================================================================
VOID pal_ResourceInactive (UINT8 ResourceNumber);

//======================================================================
// Power Down Management :
//----------------------------------------------------------------------
/// Asynchronous.\n
/// This function is called when the system reaches the Idle task loop.
/// At this time, the CPU must be set in lower power consumption mode
/// and the VCO may be switched off if all the VCO dependent resources
/// are already in power down.\n
/// This sleep state lasts until a wake up interrupt occurs.
/// The wake up interrupt may be a frame interrupt, a timer interrupt
/// or a peripheral interrupt.
//======================================================================
VOID pal_Sleep (VOID);

//======================================================================
// Calib DC Offset Getter :
//----------------------------------------------------------------------
/// This function is only used by the calibration stub to calculate
/// the average DC offset, used for "IP2" calibration.
/// This function is NOT part of the API, it should only be used by
/// calibration software.
//======================================================================
VOID pal_CalibGetDcOffset (INT16 *dco_I, INT16 *dco_Q);

//======================================================================
// Calib Tx Window Setter :
//----------------------------------------------------------------------
/// This function is only used by the calibration stub to send special
/// calibration bursts.
/// This function is NOT part of the API, it should only be used by
/// calibration software.
//======================================================================
VOID pal_CalibSetTxWin (pal_TxWin_t *win, UINT16 dacValueIdx);

/// @todo: doc
// imported from Total_integration
VOID pal_SetPcsFlag (BOOL flag);


//======================================================================
// calibration process management:
// get calibProcessEnable flag, TRUE when enable, FALSE when disable
//----------------------------------------------------------------------
BOOL pal_GetCalibProcess(VOID);

//======================================================================
// calibration process management:
// set calibProcessEnable flag, TRUE when enable, FALSE when disable
//----------------------------------------------------------------------
VOID pal_SetCalibProcess(BOOL flag);


//======================================================================
// pal_GetAfcDacOffset
// This function used to get the difference between current g_afcDacVal and AFC_MID
//----------------------------------------------------------------------
INT16 pal_GetAfcDacOffset(VOID);

//======================================================================
// pal_GetCdacOffset
// This function used to get current CDAC offset
//----------------------------------------------------------------------
INT16 pal_GetCdacOffset(VOID);

//======================================================================
// pal_UpdateAfcDacValue
// This function used to set g_afcDacVal
//----------------------------------------------------------------------
VOID pal_UpdateAfcDacValue(INT16 offset);

//======================================================================
// pal_UpdateCdacValue
// This function used to set CDAC offset
//----------------------------------------------------------------------
VOID pal_UpdateCdacValue(INT16 offset);

//======================================================================
// pal_SetFchDetectMode(UINT8 mode)
// This function used to set fch dected mode: mode 0: fch detect before afc is locked. 1: fch detect after afc is locked.
//----------------------------------------------------------------------
VOID pal_SetFchDetectMode(UINT8 mode);

//======================================================================
// pal_LimitMaxTxPower
// This function used to limit the maximum Tx power
//----------------------------------------------------------------------
VOID pal_LimitMaxTxPower(BOOL on);

///@}

///@defgroup pal_dbg_api PAL Debug Stub
///@{
typedef enum
{
    PAL_DBG_EXT_SAMPLES = 0x1,
    PAL_DBG_REC_SAMPLES = 0x2,
    PAL_DBG_REC_REF = 0x4,
    PAL_DBG_REC_TAPS = 0x8,
    PAL_DBG_BST_PARAM = 0x10,
} PAL_DBG_REQ_T;
VOID pal_DbgOpen(UINT32* ext_samples,UINT32* samples,UINT32* ref,UINT32* taps);
VOID pal_DbgReq(PAL_DBG_REQ_T req);
PAL_DBG_REQ_T pal_DbgCheckAck(VOID);
///@}
#if 1

VOID pal_GetNBurstResultMultslot (UINT8 bstIdx, UINT16 arfcn, pal_NBurstResult_t * res);

#endif
//======================================================================
// pal_LimitMaxTxPower
// This function used to judge the two or Tri or four Band Search support
//----------------------------------------------------------------------

UINT8  pal_GetTriBandSearchSupport(VOID);

//======================================================================
// pal_TimeTuningSuspend
//----------------------------------------------------------------------
// Function used to suspend a time tunning of small drifts.
//
// @param tof The timing offset expressed in ?bits (12/13 us)
//            corresponding to the timing drift to be compensated
//            by PAL.
//======================================================================
VOID pal_TimeTuningSuspend (BOOL on, INT8 tof);


//======================================================================
// pal_TimeTuningSuspendCheck
//----------------------------------------------------------------------
// Function used to suspend a time tunning of small drifts.
//
// @param  none
//======================================================================
VOID pal_TimeTuningSuspendCheck (VOID);
//======================================================================
// switch the result snap to next
VOID  pal_SnapToNext ();

//======================================================================
// pch nblock decode done irq request management
// enable or disable pch decode done irq
VOID  pal_CchDecDoneIrqEnable(BOOL flag);

//======================================================================
// pal_GetBcpuSysFreq
//----------------------------------------------------------------------
// return current BCPU freq
//======================================================================
UINT32 pal_GetBcpuSysFreq();
//======================================================================
// pal_SetUSF
// pass the assigned USF of 4 slots to bcpu
//======================================================================
VOID pal_SetUSF(UINT8 USF0, UINT8 USF1,UINT8 USF2,UINT8 USF3);

//======================================================================
//  pal_CloseToNextFINT
// This function used to check whether it is close to next FINT, compare the time left with threshold
//----------------------------------------------------------------------
 UINT8 pal_CloseToNextFINT(VOID);
 
//======================================================================
//  pal_EnableSaic
// This function used to update saic status according the state of pll
//----------------------------------------------------------------------
//======================================================================
VOID pal_EnableSaic(UINT32 flag);
 
extern UINT8 pal_fch_sync_max_attempt;
#define PAL_SYNCH_MAX_ATTEMPT   pal_fch_sync_max_attempt
#endif

