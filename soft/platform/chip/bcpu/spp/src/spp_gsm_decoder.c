/* Copyright (C) 2016 RDA Technologies Limited and/or its affiliates("RDA").
* All rights reserved.
*
* This software is supplied "AS IS" without any warranties.
* RDA assumes no responsibility or liability for the use of the software,
* conveys no license or title under any patent, copyright, or mask work
* right to the product. RDA reserves the right to make changes in the
* software without notification.  RDA also make no representation or
* warranty that such application will be suitable for the specified use
* without further testing or modification.
*/




#include "cs_types.h"
#include "gsm.h"
#include "baseband_defs.h"
#include "global_macros.h"

// SPAL PUBLIC HEADER
#include "spal_vitac.h"
#include "spal_xcor.h"
#include "spal_cap.h"

// SPP PUBLIC HEADER
#include "spp_gsm.h"
#include "spp_profile_codes.h"
// SPP PRIVATE HEADERS
#include "sppp_cfg.h"
#include "sppp_gsm_private.h"

#include "sppp_debug.h"

#ifdef __MBOX_DEBUG__ // DEBUG STUB
#include "spc_mailbox.h"
#include "comregs.h"
#endif




//------------------------------------------------------------------------------
// Functions
//------------------------------------------------------------------------------


//=============================================================================
// spp_CorrectCS4
//-----------------------------------------------------------------------------
/// CRC decoding and correcting function for the code
/// generated by g(X) = X^16+X^12+X^5+1 .
/// As g(X) = (X+1) x p(X) it can be decoded like the
/// hamming code generated by p(X) = X^15+X^14+X^13+X^12+X^4+X^2+X^2+X+1
/// combined with a parity check.
///
/// @param input UINT8*. Pointer to the soft values.
/// @return UINT8. ????
///
//=============================================================================
PRIVATE UINT8 spp_CorrectCS4(UINT8* input)
{
#define CS4_CORR_N 447 // size of the codewords r(X)
#define CS4_CORR_K 431 // size of the uncoded word
#define CS4_CORR_MASK (1<<(CS4_CORR_N-CS4_CORR_K-1))
// p(X)=X^15+X^14+X^13+X^12+X^4+X^2+X^2+X+1
#define CS4_CORR_P (0xF01F & (CS4_CORR_MASK-1))
// pattern = X^15 x X^447 % p(X)
#define CS4_CORR_PATTERN 0x49F7
    UINT32 Register=0;
    UINT16 i;
    UINT8 Sigma=0;

    SPP_PROFILE_FUNCTION_ENTRY(spp_CorrectCS4);
    // first step : X^15 x r(X) % p(X) and check the parity
    for(i=0; i<CS4_CORR_K; i++)
    {
        Register=Register*2;
        if(( (Register&CS4_CORR_MASK)&&( !(input[i / 8] & 1 << (i % 8)))) ||
                (!(Register&CS4_CORR_MASK)&&(!!(input[i / 8] & 1 << (i % 8))))  )
            Register=(Register&(CS4_CORR_MASK-1))^CS4_CORR_P;
        Sigma=(Sigma+!!(input[i / 8] & 1 << (i % 8)))%2;
    }

    // the CRC bits are inversed
    for(i=CS4_CORR_K; i<CS4_CORR_N; i++)
    {
        Register=Register*2;
        if(( (Register&CS4_CORR_MASK)&&(!!(input[i / 8] & 1 << (i % 8)))) ||
                (!(Register&CS4_CORR_MASK)&&(!(input[i / 8] & 1 << (i % 8))))   )
            Register=(Register&(CS4_CORR_MASK-1))^CS4_CORR_P;
        Sigma=(Sigma+!(input[i / 8] & 1 << (i % 8)))%2;
    }

    if (((Register&(CS4_CORR_MASK-1))==0)&&(Sigma==0)) return 0;   // no errors have been detected
    else if ( ((Register&(CS4_CORR_MASK-1))) && (Sigma==1) ) // odd pattern of error has been detected
    {
        for(i=0; i<CS4_CORR_N; i++)
        {
            if((Register&(CS4_CORR_MASK-1))==CS4_CORR_PATTERN)
            {
                input[i / 8] ^= 1<< (i % 8);
                return 0;
            }
            else
            {
                Register=Register*2;
                if (Register&CS4_CORR_MASK)
                    Register=(Register&(CS4_CORR_MASK-1))^CS4_CORR_P;
            }
        }
        return 1;
    }
    else return 1; // either error pattern not divisible by p(X) or odd error pattern divisible by p(X)
    SPP_PROFILE_FUNCTION_EXIT(spp_CorrectCS4);
}

//=============================================================================
// spp_ReorderFR_EFR
//-----------------------------------------------------------------------------
// This function gathers FR/EFR reordering as well as CRC checks.
// The main purpose is to save stack usage for non-FR/EFR decoding
//=============================================================================
VOID spp_ReorderFR_EFR(SPP_CODING_SCHEME_T coding_scheme,
                       UINT32* ViterbiOut,
                       UINT32* BufferIn,
                       UINT32* BufferOut,
                       UINT32* ConvOut,
                       SPP_N_BLOCK_RESULT_T* Res)
{
    UINT32 crccode[2];     // CRC code
    UINT32 dividend[3];    // For CRC decoding for EFR
    UINT8 buffer1[260], buffer2[252]; // Stack hungry tables
    UINT32 *pbuffer2 = (UINT32*)buffer2; // For CRC decoding
    UINT8* pBufferIn = (UINT8 *)BufferIn;
    UINT32* tmp_word=ConvOut;// reused to save space in stack
    UINT32 i,j,k;
    UINT32 tmp_buf;
    UINT8 nb_diff;

    // Input: 185 bits
    // Output: 182 bits (-3 parity bits)
    for (i=0; i<91; i++)
    {
        j=2*i;
        buffer1[j] = !!(ViterbiOut[i/32] & 1<<(i%32));
        j++;
        k = 184 - i;
        buffer1[j] = !!(ViterbiOut[k/32] & 1<<(k%32));
    }

    // Prepare data for CRC decoding (53 bits)
    // -----------------------------
    // 50 class 1a bits + 3 parity bits
    pbuffer2[0] = pbuffer2[1] = 0;
    for (i=0; i<32; i++)
        pbuffer2[0] |= buffer1[i] << i;
    for (i=0; i<18; i++)
        pbuffer2[1] |= buffer1[i+32] << i;
    // Concatenate 3 parity bits
    pbuffer2[1] |= (ViterbiOut[2]&0x38000000) >> 9;

    // CRC decoding (53 bits)
    // ------------
    spal_CapDecodeCrc(g_sppCsCrcParam[CS_FR], pbuffer2, crccode);
    if (crccode[0]==0x7)  // OK
        Res->Bfi = 0;
    else  // Failed
        Res->Bfi = 1;

    // Calculate BitError
    // ------------------
    // 378 = 11*32 + 26 -> set the last 6 bits of ConvOut to 0
    ConvOut[11] &= 0x03FFFFFF;
    Res->BitTotal=378;
    // 8 bit: 378 = 94*4 + 2 -> set the last 2 bytes of BufferIn to 0
    tmp_buf = BufferIn[94];
    BufferIn[94] &= 0x0000FFFF; // Clear extra bits for calculating biterror

    spal_XcorBiterror(
        95,         // number of softvalue words to be treated
        BufferIn,   // sofvalues_ptr,
        ConvOut,    // hardvalues_ptr,
        &(Res->BitError));
    BufferIn[94] = tmp_buf;  // Restore BufferOut


    // Hard decision for class 2
    // -------------------------
    // Coded bits: [378, 455]
    // original:   [182, 259] (78 bits)
    for (i=378; i<456; i++)
        buffer1[i-196] = !!(pBufferIn[i]&0x80);

    // **********************************
    // Still 260 bits to process...
    // **********************************
    //    EFR          *       FR
    // reordering &    *    reordering
    // CRC decoding    *
    // **********************************
    if(coding_scheme == CS_EFR)
    {
        // Reordering for EFR
        // Input: 260 bits
        // Output: 252 bits (8 repetition bits deleted)
        // SOFT DECISION taken for repetitions bits
        // Here buffer1[k]=w[k], buffer2[k]=s[k]
        // (see 3GPP TS 45.003:3.1.1.3)
        // Soft decision for repetition bits (8 repetition bits deleted)
        // Example: usually, we have:
        //     buffer1[182]=buffer1[183]=buffer1[184],
        // But we add them up and divide by 2 to get buffer1[184].
        buffer1[184] = (buffer1[182] + buffer1[183] + buffer1[184]) / 2;
        buffer1[187] = (buffer1[185] + buffer1[186] + buffer1[187]) / 2;
        buffer1[190] = (buffer1[188] + buffer1[189] + buffer1[190]) / 2;
        buffer1[193] = (buffer1[191] + buffer1[192] + buffer1[193]) / 2;
        for (i=0; i<252; i++)
            buffer2[i] = buffer1[g_sppMatrixEfr2Inv[i]];
        // -> Output: 252 bits

        // Prepare data for CRC decoding (73 bits=65+8)
        // -----------------------------
        // First 65 bits (see 3GPP TS 45.003:3.1.1.1)
        for (i=0; i<2; i++)
        {
            k = i*32;
            dividend[i] = 0;
            for (j=0; j<32; j++)
                dividend[i] |= (buffer2[g_sppMatrixEfr1[k+j]]) << j;
        }
        dividend[2] = buffer2[g_sppMatrixEfr1[64]];

        // Concatenate 8 parity bits
        // -------------------------
        for (i=1; i<9; i++)
            dividend[2] |= buffer2[i+243] << i;
        // -> Output: 73 bits

        // CRC decoding
        // ------------
        spal_CapDecodeCrc(g_sppCsCrcParam[CS_EFR], dividend, crccode);
        if (crccode[0]==0)  // OK
            Res->Bfi += 0;
        else  // Failed
            Res->Bfi = 1;

        // Form output data (7 words:244 bits)
        // ----------------
        for (i=0; i<8; i++)
        {
            k = i*32;
            tmp_buf = 0;
            for (j=0; j<32; j++)
                tmp_buf |= buffer2[k+j] << j;
            BufferOut[i] = tmp_buf;
        }
        BufferOut[7] &= 0x000FFFFF;

        // Sid detection
        // -------------
        tmp_word[0] = ~(BufferOut[1])&0xFFFF6000;
        tmp_word[1] = ~(BufferOut[2])&0xC000001F;
        tmp_word[2] = ~(BufferOut[3])&0x007FFFFD;
        tmp_word[3] = ~(BufferOut[4])&0xFFF00000;
        tmp_word[4] = ~(BufferOut[5])&0x00000FFF;
        tmp_word[5] = ~(BufferOut[6])&0x3FF3FFF0;
        nb_diff=0;
        for(i=0; i<6; i++)
        {
            for(j=0; j<32; j++)
            {
                nb_diff+=(UINT8)(tmp_word[i]&0x1);
                (tmp_word[i])>>=1;
                if (nb_diff>16) break;
            }
        }
        if(nb_diff>16) Res->Voc_Sid = 0;
        else if (nb_diff>1) Res->Voc_Sid = 1;
        else Res->Voc_Sid = 2;
    }
    else                                        // (coding_scheme == CS_EFR)
    {
        // Reordering & output (260 bits)
        // -------------------
        for (i=0; i<8; i++)
        {
            k = i*32;
            tmp_buf = 0;
            for (j=0; j<32; j++)
                tmp_buf |= buffer1[g_sppMatrixFrInv[k+j]] << j;
            BufferOut[i] = tmp_buf;
        }
        tmp_buf = 0;
        for (j=0; j<4; j++)
            tmp_buf |= buffer1[g_sppMatrixFrInv[256+j]] << j;
        BufferOut[8] = tmp_buf;

        // Sid detection
        // -------------
        tmp_word[0] = (BufferOut[1])&0xB6C00000;
        tmp_word[1] = (BufferOut[2])&0x0DB6DB6D;
        tmp_word[2] = (BufferOut[3])&0x6DB6C000;
        tmp_word[3] = (BufferOut[4])&0x000DB6DB;
        tmp_word[4] = (BufferOut[5])&0xDB6DB6C0;
        tmp_word[5] = (BufferOut[6])&0xC0000DB6;
        tmp_word[6] = (BufferOut[7])&0x249249B6;
        tmp_word[7] = (BufferOut[8])&0x00000009;
        nb_diff=0;
        for(i=0; i<8; i++)
        {
            for(j=0; j<32; j++)
            {
                nb_diff+=(UINT8)(tmp_word[i]&0x1);
                (tmp_word[i])>>=1;
                if (nb_diff>16) break;
            }
        }
        if (nb_diff > 16) Res->Voc_Sid = 0;
        else if (nb_diff > 1) Res->Voc_Sid = 1;
        else Res->Voc_Sid = 2;
    }
}

//======================================================================
// spp_DecodeBlock
//----------------------------------------------------------------------
// Decoding of a normal burst data block
//
// @param BufferIn UINT32*. Pointer to the deinterleaved data frame.
// @param ChMode UINT16. Channel Type (PAL API format).
// @param AmrFrameType UINT8. Type of AMR frame (set to 0 excepted for AMR).
// @param AmrMode UINT8. Codec Mode (set to 0 excepted for AMR).
// @param BufferOut UINT32*. Output pointer.
// @param Usf UINT8. Uplink State Flag.
// @param Res SPP_N_BLOCK_RESULT_T*. Pointer to the Block Result structure.
//======================================================================
PUBLIC VOID spp_DecodeBlock(UINT32* BufferIn,
                            UINT16 ChMode,
                            UINT8 AmrFrameType,
                            UINT8 AmrMode,
                            UINT32* BufferOut,
                            UINT8 Usf,
                            SPP_UNCACHED_BUFFERS_T* UncachedBuffers,
                            SPP_N_BLOCK_RESULT_T* Res)
{
    UINT32 tmp_buf;
    UINT32 ConvOut_tab[15];
    UINT32* ConvOut = MEM_ACCESS_UNCACHED(ConvOut_tab);
    UINT32 crccode[2];     // CRC code
    register UINT16 i, j, k;
    UINT32* tmp_word=ConvOut;//only to save space in stack

    UINT8* pBufferIn = (UINT8 *)BufferIn;
    UINT8 nb_diff;
    UINT8 LengthWord;

    UINT32* ViterbiOut  = (UINT32*) UncachedBuffers->DecodeVitac.ViterbiOut;
    UINT32* PunctTable;

    SPP_CODING_SCHEME_T coding_scheme;
    SPAL_VITAC_DEC_CFG_T vitacCfg;

    SPP_PROFILE_FUNCTION_ENTRY(spp_DecodeBlock);
    BufferOut = MEM_ACCESS_UNCACHED(BufferOut);
    coding_scheme = spp_GetChannelType(ChMode,AmrFrameType,AmrMode);
    Res->Bfi = 0;// initial value

    // Clean the temp buffer to avoid false Biterror detection
    for(i=0; i<16; i++) ViterbiOut[i]=0;

    // build the Vitac configuration structure
    vitacCfg.inSoftBit     = BufferIn;
    vitacCfg.survivorMem   = (UINT32*) UncachedBuffers->DecodeVitac.SurvivorMEM;
    vitacCfg.punctTable    = (UINT32*) g_sppCsPuncturingTable[coding_scheme];
    vitacCfg.convPoly0     = g_sppVitacPolyres[g_sppVitacDecParam[coding_scheme].resPoly0];
    vitacCfg.convPoly1     = g_sppVitacPolyres[g_sppVitacDecParam[coding_scheme].resPoly1];
    vitacCfg.convPoly2     = g_sppVitacPolyres[g_sppVitacDecParam[coding_scheme].resPoly2];
    vitacCfg.vitacDecParam = g_sppVitacDecParam[coding_scheme];

    PunctTable = (UINT32*) g_sppCsPuncturingTable[coding_scheme];

    // Main Switch
    switch (coding_scheme)
    {
        case CS_CS1:
            // Convolutional decoding
            // ----------------------
            spal_VitacFullDecoding(&vitacCfg,(UINT32*) ViterbiOut);

            // Redo Conv For Calculation of BitError
            // ----------------------------------
            spal_CapConvoluate(g_sppCsConvParam[CS_CS1], PunctTable, ViterbiOut, ConvOut);

            // Fire code decoding (224 bits = 184+40)
            for (i=0; i<5; i++) BufferOut[i]=ViterbiOut[i];
            BufferOut[5] = (~(ViterbiOut[5]) & 0xff000000) |
                           (ViterbiOut[5]  & 0x00ffffff);
            BufferOut[6] =  ~(ViterbiOut[6]);

            // CRC check and eventual ECC
            // --------------------------
            spal_CapDecodeCrc(g_sppCsCrcParam[CS_CS1], BufferOut, crccode);
            if (!(crccode[0]+(crccode[1]&0xFF))) // OK
                Res->Bfi = 0;
            else if (CORRECT_CS1)
                Res->Bfi = spal_CapFireCorrection(BufferOut);
            else
                Res->Bfi = 1;

            // Calculate BitError
            // ------------------
            // 456 = 14*32 + 8 -> set the last 24 bits to 0
            ConvOut[14] &= 0x000000FF;
            Res->BitTotal=456;
            spal_XcorBiterror(
                114,        // number of softvalue words to be treated
                BufferIn,   // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));
#if 0 // DEBUG : SW biterror calculation (w/ Idx)
            {
                UINT32 idx;
                UINT8 *my_sb_ptr = (UINT8*)MEM_ACCESS_UNCACHED(BufferIn);
                UINT8 *my_hd_ptr = (UINT8*)MEM_ACCESS_UNCACHED(ConvOut);
                UINT8 curr_bit;
                UINT8 error_nb = 0;

                for (idx=0; idx<16; idx++)
                    g_sppGlobalParams.debug[idx] = 0;

                for (idx=0; (idx<456)&&(error_nb<16); idx++)
                {
                    curr_bit = (my_hd_ptr[idx/8] >> (idx%8)) & 0x1;

                    if (((my_sb_ptr[idx]>>7) & 0x1) != curr_bit)
                    {
                        g_sppGlobalParams.debug[error_nb++] = idx;
                    }
                }
            }
#endif
            break;

        case CS_CS2:
            // Convolutional decoding
            // ----------------------
            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // Redo Conv for calculating BitError
            // ----------------------------------
            spal_CapConvoluate(g_sppCsConvParam[CS_CS2], PunctTable, ViterbiOut, ConvOut);

            // Reordering (shift of 3 bits)
            // ----------------------------
            BufferOut[0]  = (UINT32)Usf;
            BufferOut[0] |= (ViterbiOut[0]&0xFFFFFFC0) >> 3;
            for (i=0; i<8; i++)
            {
                BufferOut[i]   |= (ViterbiOut[i+1]&0x00000007) << 29;
                BufferOut[i+1]  = (ViterbiOut[i+1]&0xFFFFFFF8) >> 3;
            }
            BufferOut[8] |= (ViterbiOut[9]&0x00000003) << 29;

            // CRC decoding
            // ------------
            spal_CapDecodeCrc(g_sppCsCrcParam[CS_CS2], BufferOut, crccode);
            if (crccode[0]==0xFFFF)  // OK
                Res->Bfi = 0;
            else  // Failed
                Res->Bfi = 1;

            // Calculate BitError
            // ------------------
            // 456 = 14*32 + 8 -> set the last 24 bits to 0
            ConvOut[14] &= 0x000000FF;
            Res->BitTotal=456;
            spal_XcorBiterror(
                114,        // number of softvalue words to be treated
                BufferIn,   // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));
            break;

        case CS_CS3:
            // Convolutional decoding
            // ----------------------
            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // Redo Conv for calculating BitError
            // ----------------------------------
            spal_CapConvoluate(g_sppCsConvParam[CS_CS3], PunctTable, ViterbiOut, ConvOut);

            // Reordering (shift of 3 bits)
            // ----------
            BufferOut[0]  = (UINT32)Usf;
            BufferOut[0] |= (ViterbiOut[0]&0xFFFFFFC0) >> 3;
            for (i=0; i<9; i++)
            {
                BufferOut[i]   |= (ViterbiOut[i+1]&0x00000007) << 29;
                BufferOut[i+1]  = (ViterbiOut[i+1]&0xFFFFFFF8) >> 3;
            }
            BufferOut[9] |= (ViterbiOut[10]&0x00000007) << 29;
            BufferOut[10] = (ViterbiOut[10]&0x00003FF8) >> 3;


            // CRC decoding
            // ------------
            spal_CapDecodeCrc(g_sppCsCrcParam[CS_CS3], BufferOut, crccode);
            if (crccode[0] == 0xFFFF)      // Ok
                Res->Bfi = 0;
            else
                Res->Bfi = 1;

            // Calculate BitError
            // ------------------
            // 456 = 14*32 + 8 -> set the last 24 bits to 0
            ConvOut[14] &= 0x000000FF;
            Res->BitTotal=456;
            spal_XcorBiterror(
                114,        // number of softvalue words to be treated
                BufferIn,   // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));
            break;

        case CS_CS4:
            // Hard decision on soft bits
            // --------------------------
            for (i=0; i<15; i++)
            {
                ConvOut[i]=0;
                for (j=0; j<32; j++)
                {
                    ConvOut[i]|=(   !!(  BufferIn[(i<<3)+((j>>2)&0x7)]  &
                                         (0x80<<((j&0x3)<<3))  )   ) << j;
                }
            }
            // Reordering (shift of 9 bits)
            // ----------------------------
            BufferOut[0]  = (UINT32)Usf;
            BufferOut[0] |= (ConvOut[0]&0xFFFFF000) >> 9;
            for (i=0; i<13; i++)
            {
                BufferOut[i]   |= (ConvOut[i+1]&0x000001FF) << 23;
                BufferOut[i+1]  = (ConvOut[i+1]&0xFFFFFE00) >> 9;
            }
            BufferOut[13] |= (ConvOut[14]&0x000000FF) << 23;

            // CRC decoding
            spal_CapDecodeCrc(g_sppCsCrcParam[CS_CS4], BufferOut, crccode);
            if (crccode[0]==0xFFFF)  // OK
                Res->Bfi = 0;
            else  // Failed
            {
                Res->Bfi = 1;
                if(CORRECT_CS4)
                {
                    // single error correction is done here
                    if (!(spp_CorrectCS4((UINT8*) BufferOut))) Res->Bfi = 2;
                }
            }
            // Calculate BitError
            // ------------------
            // 456 = 14*32 + 8 -> set the last 24 bits to 0
            ConvOut[14] &= 0x000000FF;
            Res->BitTotal=456;
            spal_XcorBiterror(
                114,        // number of softvalue words to be treated
                BufferIn,   // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));
            break;

        case CS_HR:
            // Convolutional decoding
            // ----------------------
            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // Redo Conv For Calculation of BitError
            // ----------------------------------
            spal_CapConvoluate(g_sppCsConvParam[CS_HR], PunctTable, ViterbiOut, ConvOut);

            // CRC decoding (25 bits=22+3)
            // ------------
            tmp_buf  = (ViterbiOut[2]&0xFFFFFE00) >> 9;
            tmp_buf |= (ViterbiOut[3]&0x00000003) << 23;

            spal_CapDecodeCrc(g_sppCsCrcParam[CS_HR], &tmp_buf, crccode);
            if (crccode[0]==0x7)  // OK
                Res->Bfi = 0;
            else  // Failed
                Res->Bfi = 1;

            // Calculate BitError
            // ------------------
            // 211 = 6*32 + 19 -> set the last 13 bits of ConvOut to 0
            ConvOut[6] &= 0x0007FFFF;
            Res->BitTotal=211;
            // 8 bits: 211 = 52*4 + 3 -> set the last 1 byte of BufferIn to 0
            tmp_buf = BufferIn[52];
            BufferIn[52] &= 0x00FFFFFF; //Clear extra bits for calculating biterror
            spal_XcorBiterror(
                53,         // number of softvalue words to be treated
                BufferIn,   // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));
            BufferIn[52] = tmp_buf;  // Restore BufferIn

            // Hard decision for class 2
            // -------------------------
            // Coded bits: [211, 227] (17 bits)
            // Original:   [ 95, 111]
            ViterbiOut[2] &= 0x7FFFFFFF;
            ViterbiOut[3] = 0;
            for (i=211; i<228; i++)
                ViterbiOut[(i-116)/32] |= (!!(pBufferIn[i]&0x80)) << ((i-116)%32);

            // Reordering according to table 3a/3b
            // -----------------------------------
            tmp_buf = (ViterbiOut[2] & 0x60000000) >> 29;  // Mode(bit 93-94)
            tmp_buf = (tmp_buf)?1:0;
            for (i=0; i<3; i++)
            {
                k = i*32;
                for (j=0; j<32; j++)
                {
                    BufferOut[g_sppMatrixHr[tmp_buf][k+j]/32] |= (ViterbiOut[i] & 1) <<
                            (g_sppMatrixHr[tmp_buf][k+j]%32);
                    ViterbiOut[i] = ViterbiOut[i] >> 1;
                }
            }
            for (j=0; j<16; j++)
            {
                BufferOut[g_sppMatrixHr[tmp_buf][96+j]/32] |= (ViterbiOut[3] & 1) <<
                        (g_sppMatrixHr[tmp_buf][96+j]%32);
                ViterbiOut[3] = ViterbiOut[3] >> 1;
            }

            // Sid detection after reordering
            // ------------------------------
            tmp_word[0] = ~(BufferOut[1])&0xFFFFFFFE;
            tmp_word[1] = ~(BufferOut[2])&0xFFFFFFFF;
            tmp_word[2] = ~(BufferOut[3])&0x0000FFFF;
            nb_diff=0;
            for(i=0; i<3; i++)
            {
                for(j=0; j<32; j++)
                {
                    nb_diff+=(UINT8)(tmp_word[i] & 0x1);
                    tmp_word[i] >>= 1;
                    if (nb_diff > 16) break;
                }
            }
            if (nb_diff>16) Res->Voc_Sid = 0;
            else if (nb_diff>2) Res->Voc_Sid = 1;
            else Res->Voc_Sid = 2;
            break;

        case CS_FR:
        case CS_EFR:
            // ************************
            // Common part for FR & EFR
            // ************************
            // Convolutional decoding
            // ----------------------
            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // Redo Conv For calculating BitError
            // ----------------------------------
            spal_CapConvoluate(g_sppCsConvParam[CS_FR], PunctTable, ViterbiOut, ConvOut);

            // Reordering
            // ----------
            // NOTE: this function has been made to save stack usage
            // for non-FR/EFR decoding
            spp_ReorderFR_EFR(coding_scheme,(UINT32*)ViterbiOut,BufferIn,BufferOut,ConvOut,Res);
            break;

        case CS_F96:
        case CS_H48:
            // Convolutional decoding
            // ----------------------
            spal_VitacFullDecoding(&vitacCfg, BufferOut);

            // Redo Conv for calculating BitError
            // ----------------------------------
            spal_CapConvoluate(g_sppCsConvParam[CS_F96], PunctTable, BufferOut, ConvOut);

            // Calculate BitError
            // ------------------
            // 8-bits (for 4-bits SV). Here 456 bits -> 114 or 57 Dwords
            // 456 = 14*32 + 8 -> set the last 24 bits to 0
            ConvOut[14] &= 0x000000FF;
            Res->BitTotal=456;
            spal_XcorBiterror(
                114,        // number of softvalue words to be treated
                BufferIn,   // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));
            break;

        case CS_F48:
        case CS_H24:
            // Convolutional decoding
            // ----------------------
            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // Redo Conv for calculating BitError
            // ----------------------------------
            spal_CapConvoluate(g_sppCsConvParam[CS_F48], PunctTable, ViterbiOut, ConvOut);

            // Reordering
            // ----------
            if (coding_scheme == CS_F48)
            {
                BufferOut[0]  = ViterbiOut[0]&0x00007FFF;
                BufferOut[0] |= (ViterbiOut[0]&0xFFF80000) >> 4;
                BufferOut[0] |= (ViterbiOut[1]&0x00000003) << 28;
                BufferOut[0] |= (ViterbiOut[1]&0x000000C0) << 24;
                BufferOut[1]  = (ViterbiOut[1]&0x001FFF00) >> 8;
                BufferOut[1] |= (ViterbiOut[1]&0xFE000000) >> 12;
                BufferOut[1] |= (ViterbiOut[2]&0x000000FF) << 20;
                BufferOut[1] |= (ViterbiOut[2]&0x0000F000) << 16;
                BufferOut[2]  = (ViterbiOut[2]&0x07FF0000) >> 16;
                BufferOut[2] |= (ViterbiOut[2]&0x80000000) >> 20;
                BufferOut[2] |= (ViterbiOut[3]&0x00003FFF) << 12;
                BufferOut[2] |= (ViterbiOut[3]&0x00FC0000) <<  8;
                BufferOut[3]  = (ViterbiOut[3]&0xFF000000) >> 24;
                BufferOut[3] |= (ViterbiOut[4]&0x00000001) <<  8;
                BufferOut[3] |= (ViterbiOut[4]&0x000FFFE0) <<  4;
            }
            else // (coding_scheme == CS_H24)
            {
                BufferOut[0]  = ViterbiOut[0];
                BufferOut[1]  = ViterbiOut[1];
                BufferOut[2]  = ViterbiOut[2]&0x000000FF;
                BufferOut[2] |= (ViterbiOut[2]&0xFFFFF000) >> 4;
                BufferOut[2] |= (ViterbiOut[3]&0x0000000F) << 28;
                BufferOut[3]  = (ViterbiOut[3]&0xFFFFFFF0) >> 4;
                BufferOut[3] |= (ViterbiOut[4]&0x0000000F) << 28;
                BufferOut[4]  = (ViterbiOut[4]&0x000FFFF0) >> 4;
            }

            // Calculate BitError
            // ------------------
            // 456 = 14*32 + 8 -> set the last 24 bits to 0
            ConvOut[14] &= 0x000000FF;
            Res->BitTotal=456;
            spal_XcorBiterror(
                114,        // number of softvalue words to be treated
                BufferIn,   // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));
            break;

        case CS_F24:
            // Convolutional decoding
            // ----------------------
            spal_VitacFullDecoding(&vitacCfg, BufferOut);

            // Redo Conv for calculating BitError
            // ----------------------------------
            spal_CapConvoluate(g_sppCsConvParam[CS_F24], PunctTable, BufferOut, ConvOut);

            // Calculate BitError
            // ------------------
            // 456 = 14*32 + 8 -> set the last 24 bits to 0
            ConvOut[14] &= 0x000000FF;
            Res->BitTotal=456;
            spal_XcorBiterror(
                114,        // number of softvalue words to be treated
                BufferIn,   // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));
            break;

        case CS_F144:
            // Convolutional decoding
            // ----------------------
            spal_VitacFullDecoding(&vitacCfg, BufferOut);

            // Redo Conv for calculating BitError
            // ----------------------------------
            spal_CapConvoluate(g_sppCsConvParam[CS_F144], PunctTable, BufferOut, ConvOut);

            // Calculate BitError
            // ------------------
            // 456 = 14*32 + 8 -> set the last 24 bits to 0
            ConvOut[14] &= 0x000000FF;
            Res->BitTotal=456;
            spal_XcorBiterror(
                114,        // number of softvalue words to be treated
                BufferIn,   // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));
            break;

        case CS_AFS_SID_UPDATE:
        {
            // Viterbi channel decoding input; Extracted from BufferIn
            UINT32 ViterbiIn[112];
            // ********************************************
            // Extract data for channel decoding (212 bits)
            // ********************************************
            // 212 softbits = 53 Dwords
            for (i=0; i<53; i++)
            {
                k = i*2 + 8;
                ViterbiIn[i] = BufferIn[k];
            }

            vitacCfg.inSoftBit = ViterbiIn;

            // ************************
            // Channel decoding
            // ************************
            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // ********************************************
            // Post SRC (Systematic Recursive Convolutional)
            // ********************************************
            spal_CapConvSrc(g_sppCsSrcParam[coding_scheme-CS_NEED_SRC] ,(UINT32*)ViterbiOut,BufferOut);

            // *************************************
            // Redo Conv For Calculation of BitError
            // *************************************
            spal_CapConvoluate(g_sppCsConvParam[coding_scheme],PunctTable,BufferOut,ConvOut);

            // ***********************
            // CRC code decoding
            // ***********************
            spal_CapDecodeCrc(g_sppCsCrcParam[coding_scheme],BufferOut,crccode);
            if (crccode[0]==0x3FFF)  // OK
                Res->Bfi = 0;
            else  // Failed
                Res->Bfi = 1;

            // Calculate BitError (during CRC decoding)
            // XCOR module works with a granularity of one Dword of soft-values,
            // therefore it compares a minimum of 4-bits (for 8-bits SV) or
            // 8-bits (for 4-bits SV). Here 212 bits -> 53 or 27 Dwords
            // 212 = 6*32 + 20 -> set the last 12 bits of ConvOut to 0
            ConvOut[6] &= 0x000FFFFF;
            Res->BitTotal=212;
            spal_XcorBiterror(
                53,         // number of softvalue words to be treated
                ViterbiIn,  // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));

            // ****************************
            // Form output bits
            // ****************************
            BufferOut[2] &= 0x00000007;
        }
        break;

        case CS_AFS_SPEECH_122:
        case CS_AFS_SPEECH_102:
        case CS_AFS_SPEECH_795:
        case CS_AFS_SPEECH_74:
        case CS_AFS_SPEECH_67:
        case CS_AFS_SPEECH_59:
        case CS_AFS_SPEECH_515:
        case CS_AFS_SPEECH_475:
        {
            UINT32 PostSRCOut_tab[8];  // Output of Post SRC
            UINT32* PostSRCOut = MEM_ACCESS_UNCACHED(PostSRCOut_tab);
            UINT32 d[8];  // Input of reordering
            UINT8 ReorderBitLeft;

            vitacCfg.inSoftBit = BufferIn+2;

            // ************************
            // Channel decoding
            // ************************
            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // ********************************************
            // Post SRC (Systematic Recursive Convolutional)
            // ********************************************
            spal_CapConvSrc(g_sppCsSrcParam[coding_scheme-CS_NEED_SRC] ,(UINT32*)ViterbiOut,PostSRCOut);

            // *************************************
            // Redo Conv For Calculation of BitError
            // *************************************
            spal_CapConvoluate(g_sppCsConvParam[coding_scheme],PunctTable,PostSRCOut,ConvOut);

            // ******************
            // delete CRC code
            // ******************
            d[0] = PostSRCOut[0];  // Common operation for all the channels
            switch (AmrMode)
            {
                case SPP_MR122_MODE://AFS_12_2:
                    d[1] = PostSRCOut[1];
                    d[2] = (PostSRCOut[2]&0x0001FFFF) | ((PostSRCOut[2]&0xFF800000) >> 6);
                    for (i=2; i<7; i++)
                    {
                        d[i] |= PostSRCOut[i+1] << 26;
                        d[i+1] = PostSRCOut[i+1] >> 6;
                    }
                    d[7] &= 0x000FFFFF;
                    break;
                case SPP_MR102_MODE://AFS_10_2:
                    d[1] = PostSRCOut[1];
                    d[2] = (PostSRCOut[2]&0x00000001) | ((PostSRCOut[2]&0xFFFFFF80) >> 6);
                    for (i=2; i<6; i++)
                    {
                        d[i] |= PostSRCOut[i+1] << 26;
                        d[i+1] = PostSRCOut[i+1] >> 6;
                    }
                    d[6] &= 0x00000FFF;
                    break;
                case SPP_MR795_MODE://AFS_7_95:
                    d[1] = PostSRCOut[1];
                    d[2] = (PostSRCOut[2]&0x000007FF) | ((PostSRCOut[2]&0xFFFE0000) >> 6);
                    for (i=2; i<5; i++)
                    {
                        d[i] |= PostSRCOut[i+1] << 26;
                        d[i+1] = PostSRCOut[i+1] >> 6;
                    }
                    d[4] &= 0x7FFFFFFF;
                    break;
                case SPP_MR74_MODE://AFS_7_4:
                    d[1] = PostSRCOut[1]&0x1FFFFFFF;
                    d[1] |= (PostSRCOut[2]&0x00000038) << 26;
                    for (i=2; i<4; i++)
                    {
                        d[i] = PostSRCOut[i] >> 6;
                        d[i] |= PostSRCOut[i+1] << 26;
                    }
                    d[4] = PostSRCOut[4] >> 6;
                    d[4] &= 0x000FFFFF;
                    break;
                case SPP_MR67_MODE://AFS_6_7:
                    d[1] = (PostSRCOut[1]&0x007FFFFF) | ((PostSRCOut[1]&0xE0000000) >> 6);
                    for (i=1; i<4; i++)
                    {
                        d[i] |= PostSRCOut[i+1] << 26;
                        d[i+1] = PostSRCOut[i+1] >> 6;
                    }
                    d[4] &= 0x0000003F;
                    break;
                case SPP_MR59_MODE://AFS_5_9:
                    d[1] = (PostSRCOut[1]&0x007FFFFF) | ((PostSRCOut[1]&0xE0000000) >> 6);
                    for (i=1; i<3; i++)
                    {
                        d[i] |= PostSRCOut[i+1] << 26;
                        d[i+1] = PostSRCOut[i+1] >> 6;
                    }
                    d[3] &= 0x003FFFFF;
                    break;
                case SPP_MR515_MODE://AFS_5_15:
                    d[1] = (PostSRCOut[1]&0x0001FFFF) | ((PostSRCOut[1]&0xFF800000) >> 6) | (PostSRCOut[2] << 26);
                    d[2] = (PostSRCOut[2] >> 6) | (PostSRCOut[3] << 26);
                    d[3] = PostSRCOut[3] >> 6;
                    d[3] &= 0x0000007F;
                    break;
                case SPP_MR475_MODE://AFS_4_75:
                    d[1] = (PostSRCOut[1]&0x0000007F) | ((PostSRCOut[1]&0xFFFFE000) >> 6) | (PostSRCOut[2] << 26);
                    d[2] = (PostSRCOut[2] >> 6) | (PostSRCOut[3] << 26);
                    d[2] &= 0x7FFFFFFF;
                    break;
                default:
                    break;
            }


            // ***********************
            // CRC code decoding
            // ***********************
            spal_CapDecodeCrc(g_sppCsCrcParam[coding_scheme],PostSRCOut,crccode);
            if (crccode[0]==0x3F)  // OK
                Res->Bfi = 0;
            else  // Failed
                Res->Bfi = 1;

            // Calculate BitError (during CRC decoding)
            // XCOR module works with a granularity of one Dword of soft-values,
            // therefore it compares a minimum of 4-bits (for 8-bits SV) or
            // 8-bits (for 4-bits SV). Here 448 bits -> 112 or 56 Dwords
            // 448 = 14*32
            Res->BitTotal=448;
            spal_XcorBiterror(
                112,        // number of softvalue words to be treated
                BufferIn+2, // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));


            // **********************************************
            // Reordering according to table 7-14 in 45.003
            // **********************************************
            LengthWord = g_sppInputLengthBitAfs[AmrMode]/32 + 1;
            ReorderBitLeft = g_sppInputLengthBitAfs[AmrMode]%32;
            for (i=0; i<LengthWord; i++)
            {
                k = i*32;
                for (j=0; j<32; j++)
                    BufferOut[g_sppAfsReorderTables[AmrMode][k+j]/32] |= (!!(d[i] & (1<<j))) << (g_sppAfsReorderTables[AmrMode][k+j]%32);
            }
            i--;
            k = i*32;
            for (j=0; j<ReorderBitLeft; j++)
                BufferOut[g_sppAfsReorderTables[AmrMode][k+j]/32] |= (!!(d[i] & (1<<j))) << (g_sppAfsReorderTables[AmrMode][k+j]%32);
        }
        break;

        case CS_AFS_RATSCCH:
        {
            // Viterbi channel decoding input; Extracted from BufferIn

            vitacCfg.inSoftBit = BufferIn+61;

            // ************************
            // Channel decoding
            // ************************
            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // ********************************************
            // Post SRC (Systematic Recursive Convolutional)
            // ********************************************
            spal_CapConvSrc(g_sppCsSrcParam[coding_scheme-CS_NEED_SRC] ,(UINT32*)ViterbiOut,BufferOut);

            // *************************************
            // Redo Conv For Calculation of BitError
            // *************************************
            spal_CapConvoluate(g_sppCsConvParam[coding_scheme],PunctTable,BufferOut,ConvOut);

            // ***********************
            // CRC code decoding
            // ***********************
            spal_CapDecodeCrc(g_sppCsCrcParam[coding_scheme],BufferOut,crccode);
            if (crccode[0]==0x3FFF)  // OK
                Res->Bfi = 0;
            else  // Failed
                Res->Bfi = 1;

            // Calculate BitError (during CRC decoding)
            // XCOR module works with a granularity of one Dword of soft-values,
            // therefore it compares a minimum of 4-bits (for 8-bits SV) or
            // 8-bits (for 4-bits SV). Here 212 bits -> 53 or 27 Dwords
            // 212 = 6*32 + 20 -> set the last 12 bits of ConvOut to 0
            ConvOut[6] &= 0x000FFFFF;
            Res->BitTotal=212;
            spal_XcorBiterror(
                53,         // number of softvalue words to be treated
                BufferIn+61,    // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));


            // ****************************
            // Form output bits
            // ****************************
            BufferOut[2] &= 0x00000007;
        }
        break;

        case CS_AHS_SID_UPDATE:
        {
            // Viterbi decoding input: BufferIn starts at the second
            // part of the SID_UPDATE
            UINT32 *ViterbiIn=BufferIn+4;
            // ********************************************
            // Extract data for channel decoding (212 bits)
            // ********************************************
            /*
                        // 212 softbits = 53 Dwords
                        for (i=0; i<53; i++)
                            ViterbiIn[i] = BufferIn[i+61];
            */

            vitacCfg.inSoftBit = ViterbiIn;

            // ************************
            // Channel decoding
            // ************************
            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // ********************************************
            // Post SRC (Systematic Recursive Convolutional)
            // ********************************************
            spal_CapConvSrc(g_sppCsSrcParam[coding_scheme-CS_NEED_SRC] ,(UINT32*)ViterbiOut,BufferOut);

            // *************************************
            // Redo Conv For Calculation of BitError
            // *************************************
            spal_CapConvoluate(g_sppCsConvParam[coding_scheme],PunctTable,BufferOut,ConvOut);

            // ***********************
            // CRC code decoding
            // ***********************
            spal_CapDecodeCrc(g_sppCsCrcParam[coding_scheme],BufferOut,crccode);
            if (crccode[0]==0x3FFF)  // OK
                Res->Bfi = 0;
            else  // Failed
                Res->Bfi = 1;

            // Calculate BitError (during CRC decoding)
            // XCOR module works with a granularity of one Dword of soft-values,
            // therefore it compares a minimum of 4-bits (for 8-bits SV) or
            // 8-bits (for 4-bits SV). Here 212 bits -> 53 or 27 Dwords
            // 212 = 6*32 + 20 -> set the last 12 bits of ConvOut to 0
            ConvOut[6] &= 0x000FFFFF;
            Res->BitTotal=212;
            spal_XcorBiterror(
                53,         // number of softvalue words to be treated
                ViterbiIn,  // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));


            // ****************************
            // Form output bits
            // ****************************
            BufferOut[2] &= 0x00000007;
        }
        break;

        case CS_AHS_SPEECH_795:
        case CS_AHS_SPEECH_74:
        case CS_AHS_SPEECH_67:
        case CS_AHS_SPEECH_59:
        case CS_AHS_SPEECH_515:
        case CS_AHS_SPEECH_475:
        {
            // Viterbi decoding input
            UINT8* ViterbiIn_8 = (UINT8*)(BufferIn+1);
            UINT32 PostSRCOut_tab[5];  // Output of Post SRC
            UINT32* PostSRCOut = MEM_ACCESS_UNCACHED(PostSRCOut_tab);
            UINT32 d[5];  // Input of reordering
            UINT8 ReorderBitLeft;

            // ***************************************
            // Extract data for channel decoding
            // 224 bits: bit 4 -> bit 227
            // ***************************************
            // ************************
            // Channel decoding
            // ************************

            vitacCfg.inSoftBit = BufferIn+1;

            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // ********************************************
            // Post SRC (Systematic Recursive Convolutional)
            // ********************************************
            spal_CapConvSrc(g_sppCsSrcParam[coding_scheme-CS_NEED_SRC] ,(UINT32*)ViterbiOut,PostSRCOut);

            // *************************************
            // Redo Conv For Calculation of BitError
            // *************************************
            spal_CapConvoluate(g_sppCsConvParam[coding_scheme], PunctTable, PostSRCOut, ConvOut);

            LengthWord = g_sppConvOutLengthBitAhs[AmrMode]/32+1;
            ConvOut[LengthWord-1] &= g_sppConvOutMaskAhs[AmrMode];


            // ******************************************
            // Extract output data (delete CRC code) +
            // Hard decision for class 2 & concatenation
            // ******************************************
            d[0] = PostSRCOut[0];  // Common operation for all the channels
            switch (AmrMode)
            {
                case SPP_MR795_MODE://AHS_7_95:
                    d[1] = PostSRCOut[1];
                    d[2] = (PostSRCOut[2] & 0x00000007) | ((PostSRCOut[2] & 0xFFFFFE00) >> 6) | (PostSRCOut[3] << 26);
                    d[3] = (PostSRCOut[3] >> 6) | (PostSRCOut[4] << 26);
                    d[3] &= 0x07FFFFFF;
                    d[4] = 0;
                    // Hard decision for class 2 & concatenation
                    //  BufferIn(192, 227) -> d(123, 158)
                    // ViterbiIn(188, 223) -> d(123, 158)
                    for (i=27; i<32; i++)
                        d[3] |= (!!(ViterbiIn_8[i+161]&0x80)) << i;
                    for (i=0; i<31; i++)
                        d[4] |= (!!(ViterbiIn_8[i+193]&0x80)) << i;
                    break;
                case SPP_MR74_MODE://AHS_7_4:
                    d[1] = (PostSRCOut[1] & 0x1FFFFFFF) | ((PostSRCOut[2] & 0x00000038) << 26);
                    d[2] = (PostSRCOut[2] >> 6) | (PostSRCOut[3] << 26);
                    d[3] = PostSRCOut[3] >> 6;
                    d[3] &= 0x00FFFFFF;
                    d[4] = 0;
                    // Hard decision for class 2 & concatenation
                    //  BufferIn(200, 227) -> d(120, 147)
                    // ViterbiIn(196, 223) -> d(120, 147)
                    for (i=24; i<32; i++)
                        d[3] |= (!!(ViterbiIn_8[i+172]&0x80)) << i;
                    for (i=0; i<20; i++)
                        d[4] |= (!!(ViterbiIn_8[i+204]&0x80)) << i;
                    break;
                case SPP_MR67_MODE://AHS_6_7:
                    d[1] = (PostSRCOut[1] & 0x007FFFFF) | ((PostSRCOut[1] & 0xE0000000) >> 6) | (PostSRCOut[2] << 26);
                    d[2] = (PostSRCOut[2] >> 6) | (PostSRCOut[3] << 26);
                    d[3] = PostSRCOut[3] >> 6;
                    d[3] &= 0x00003FFF;
                    d[4] = 0;
                    // Hard decision for class 2 & concatenation
                    //  BufferIn(204, 227) -> d(110, 133)
                    // ViterbiIn(200, 223) -> d(110, 133)
                    for (i=14; i<32; i++)
                        d[3] |= (!!(ViterbiIn_8[i+186]&0x80)) << i;
                    for (i=0; i<6; i++)
                        d[4] |= (!!(ViterbiIn_8[i+218]&0x80)) << i;
                    break;
                case SPP_MR59_MODE://AHS_5_9:
                    d[1] = (PostSRCOut[1] & 0x007FFFFF) | ((PostSRCOut[1] & 0xE0000000) >> 6) | (PostSRCOut[2] << 26);
                    d[2] = (PostSRCOut[2] >> 6) | (PostSRCOut[3] << 26);
                    d[3] = PostSRCOut[3] >> 6;
                    d[3] &= 0x0000003F;
                    // Hard decision for class 2 & concatenation
                    //  BufferIn(212, 227) -> d(102, 117)
                    // ViterbiIn(208, 223) -> d(102, 117)
                    for (i=6; i<22; i++)
                        d[3] |= (!!(ViterbiIn_8[i+202]&0x80)) << i;
                    break;
                case SPP_MR515_MODE:
                    d[1] = (PostSRCOut[1] & 0x0001FFFF) | ((PostSRCOut[1] & 0xFF800000) >> 6) | (PostSRCOut[2] << 26);
                    d[2] = (PostSRCOut[2] >> 6) | (PostSRCOut[3] << 26);
                    d[2] &= 0x07FFFFFF;
                    d[3] = 0;
                    // Hard decision for class 2 & concatenation
                    //  BufferIn(216, 227) -> d( 91, 102)
                    // ViterbiIn(212, 223) -> d( 91, 102)
                    for (i=27; i<32; i++)
                        d[2] |= (!!(ViterbiIn_8[i+185]&0x80)) << i;
                    for (i=0; i<7; i++)
                        d[3] |= (!!(ViterbiIn_8[i+217]&0x80)) << i;
                    break;
                case SPP_MR475_MODE://AHS_4_75:
                    d[1] = (PostSRCOut[1] & 0x0000007F) | ((PostSRCOut[1] & 0xFFFFE000) >> 6) | (PostSRCOut[2] << 26);
                    d[2] = PostSRCOut[2] >> 6;
                    d[2] &= 0x0007FFFF;
                    // Hard decision for class 2 & concatenation
                    //  BufferIn(216, 227) -> d( 83,  94)
                    // ViterbiIn(212, 223) -> d( 83,  94)
                    for (i=19; i<31; i++)
                        d[2] |= (!!(ViterbiIn_8[i+193]&0x80)) << i;
                    break;
                default:
                    break;
            }


            // *************************
            // CRC decoding
            // *************************
            spal_CapDecodeCrc(g_sppCsCrcParam[coding_scheme],PostSRCOut,crccode);
            if (crccode[0]==0x3F)  // OK
                Res->Bfi = 0;
            else  // Failed
                Res->Bfi = 1;

            // Calculate BitError (during CRC decoding)
            // XCOR module works with a granularity of one Dword of soft-values,
            // therefore it compares a minimum of 4-bits (for 8-bits SV) or
            // 8-bits (for 4-bits SV).
            // 188 SV: 47/23.5 Dwords, 188=5*32+28: clear the last  4 bits of ConvOut
            // 196 SV: 49/24.5 Dwords, 196=6*32+ 4: clear the last 28 bits of ConvOut
            // 200 SV: 50/25 Dwords, 200=6*32+ 8: clear the last 24 bits of ConvOut
            // 208 SV: 52/26 Dwords, 208=6*32+16: clear the last 16 bits of ConvOut
            // 212 SV: 53/26.5 Dwords, 212=6*32+20: clear the last 12 bits of ConvOut
            // 212 SV: 53/26.5 Dwords, 212=6*32+20: clear the last 12 bits of ConvOut
            Res->BitTotal=g_sppConvOutLengthBitAhs[AmrMode];
            LengthWord = g_sppConvOutLengthBitAhs[AmrMode] >> 2;
            spal_XcorBiterror(
                LengthWord, // number of softvalue words to be treated
                BufferIn+1, // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));

            // **********************************************
            // Reordering according to table 9-14 in 45.003
            // **********************************************
            LengthWord = g_sppInputLengthBitAhs[AmrMode]/32 + 1;
            ReorderBitLeft = g_sppInputLengthBitAhs[AmrMode]%32;
            for (i=0; i<LengthWord; i++)
            {
                k = i*32;
                for (j=0; j<32; j++)
                    BufferOut[g_sppAhsReorderTables[AmrMode][k+j]/32] |= (!!(d[i] & (1<<j))) << (g_sppAhsReorderTables[AmrMode][k+j]%32);
            }
            i--;
            k = i*32;
            for (j=0; j<ReorderBitLeft; j++)
                BufferOut[g_sppAhsReorderTables[AmrMode][k+j]/32] |= (!!(d[i] & (1<<j))) << (g_sppAhsReorderTables[AmrMode][k+j]%32);
        }
        break;

        case CS_AHS_RATSCCH_DATA:
        {
            // ************************
            // Channel decoding
            // ************************

            vitacCfg.inSoftBit = BufferIn+4;

            spal_VitacFullDecoding(&vitacCfg, (UINT32*)ViterbiOut);

            // ********************************************
            // Post SRC (Systematic Recursive Convolutional)
            // ********************************************
            spal_CapConvSrc(g_sppCsSrcParam[coding_scheme-CS_NEED_SRC] ,(UINT32*)ViterbiOut,BufferOut);

            // *************************************
            // Redo Conv For Calculation of BitError
            // *************************************
            spal_CapConvoluate(g_sppCsConvParam[coding_scheme],PunctTable,BufferOut,ConvOut);

            // ***********************
            // CRC code decoding
            // ***********************
            spal_CapDecodeCrc(g_sppCsCrcParam[coding_scheme],BufferOut,crccode);
            if (crccode[0]==0x3FFF)  // OK
                Res->Bfi = 0;
            else  // Failed
                Res->Bfi = 1;

            // Calculate BitError (during CRC decoding)
            // XCOR module works with a granularity of one Dword of soft-values,
            // therefore it compares a minimum of 4-bits (for 8-bits SV) or
            // 8-bits (for 4-bits SV). Here 212 bits -> 53 or 27 Dwords
            // 212 = 6*32 + 20 -> set the last 12 bits of ConvOut to 0
            ConvOut[6] &= 0x000FFFFF;
            Res->BitTotal=212;
            spal_XcorBiterror(
                53,         // number of softvalue words to be treated
                BufferIn+4, // sofvalues_ptr,
                ConvOut,    // hardvalues_ptr,
                &(Res->BitError));


            // ****************************
            // Form output bits
            // ****************************
            BufferOut[2] &= 0x00000007;
        }
        break;

        default: break;
    }

    // MeanBEP & CvBEP Update
    // ----------------------
    if (Res->Bfi == 0)
    {
        Res->MeanBEP=(((Res->BitError)<<5)/(Res->BitTotal))&0x1F;
        if      (Res->MeanBEP<1)  Res->CvBEP  =0x7;
        else if (Res->MeanBEP<2)  Res->CvBEP  =0x6;
        else if (Res->MeanBEP<3)  Res->CvBEP  =0x4;
        else if (Res->MeanBEP<5)  Res->CvBEP  =0x3;
        else if (Res->MeanBEP<10) Res->CvBEP  =0x2;
        else if (Res->MeanBEP<24) Res->CvBEP  =0x1;
        else                      Res->CvBEP  =0x0;
    }
    else
    {
        Res->MeanBEP=0xFF;
        Res->CvBEP  =0xFF;
    }
    SPP_PROFILE_FUNCTION_EXIT(spp_DecodeBlock);
}

