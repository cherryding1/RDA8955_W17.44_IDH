/* Copyright (C) 2016 RDA Technologies Limited and/or its affiliates("RDA").
* All rights reserved.
*
* This software is supplied "AS IS" without any warranties.
* RDA assumes no responsibility or liability for the use of the software,
* conveys no license or title under any patent, copyright, or mask work
* right to the product. RDA reserves the right to make changes in the
* software without notification.  RDA also make no representation or
* warranty that such application will be suitable for the specified use
* without further testing or modification.
*/


#include "cs_types.h"
#include "chip_id.h"
#include "string.h"

#include "calib_m.h"
#include "calibp_defaults.h"
#include "calibp_debug.h"
#include "calibp_calibration.h"

#include "pal_gsm.h"
#include "hal_mem_map.h"
#include "hal_dma.h"
#include "hal_host.h"
#include "hal_map_engine.h"

#ifdef CHIP_HAS_AP
#include "hal_ap_comm.h"
#include "syscmds_m.h"
#endif

#include "sxr_mem.h"
#include "sxr_tls.h"

#include "memd_m.h"
#ifdef __VDS_QUICK_FLUSH__
#include "tgt_m.h"
#include "memd_cache.h"
#include "memd_map.h"
#include "vds_cache.h"
#endif
#include "rfd_pa.h"
#include "rfd_sw.h"
#include "rfd_xcv.h"
extern UINT8 g_Calib_OnSite;
extern VOID calib_ConvertStructV2p2(CALIB_BB_T *pCalibBb);
extern VOID calib_ConvertStructV2p4(CALIB_BB_T *pCalibBb);
extern VOID calib_ConvertStructV2p5(CALIB_BB_T *pCalibBb);
#ifdef __VDS_QUICK_FLUSH__
extern VOID DRV_SuspendDisable(VOID);
#endif

#define STR(x) #x

// Check the chip ID generated by CAT tool
#if (DEFAULT_CALIB_CHIP_ID != CHIP_ASIC_ID)
#define CHIP_ID_ERR(catChipId, chipId) \
    STR(DEFAULT_CALIB_CHIP_ID [catChipId]  \
            in calibp_audio_defaults.h is incorrect. Should be  \
            [chipId])
#include CHIP_ID_ERR(DEFAULT_CALIB_CHIP_ID, CHIP_ASIC_ID)
#endif

#if (CHIP_ASIC_ID == CHIP_ASIC_ID_GALLITE)
#if (DEFAULT_CALIB_CHIP_DIE == 8805)
#if !defined(GALLITE_IS_8805)
#error "DEFAULT_CALIB_CHIP_DIE [8805] in calibp_audio_defaults.h is incorrect."
#endif
#elif (DEFAULT_CALIB_CHIP_DIE == 8806)
#if !defined(GALLITE_IS_8806)
#error "DEFAULT_CALIB_CHIP_DIE [8806] in calibp_audio_defaults.h is incorrect."
#endif
#else // not 8805 or 8806
#error "DEFAULT_CALIB_CHIP_DIE in calibp_audio_defaults.h is invalid."
#endif
#endif // CHIP_ASIC_ID_GALLITE

// Check the calib version generated by CAT tool
#if (DEFAULT_CALIB_VERSION != CALIB_VERSION_NUMBER)
#define VERSION_ERR(catCalibVer, calibVer) \
    STR(DEFAULT_CALIB_VERSION [catCalibVer] \
            in calibp_audio_defaults.h is incorrect. Should be \
            [calibVer])
#include VERSION_ERR(DEFAULT_CALIB_VERSION, CALIB_VERSION_NUMBER)
#endif


// =============================================================================
// Definitions
// =============================================================================

#define CALIB_CHECK_RF_NAME 1

#define CALIB_CHECK_MINOR_VERSION 1

#define CALIB_UNCACHED_BSS __attribute__((section(".ucbss")))


// =============================================================================
// _calib_start
// -----------------------------------------------------------------------------
/// Start address of the calibration sector, in the flash.
/// Come from the linker.
// =============================================================================
extern CALIB_BUFFER_T _calib_start;


// =============================================================================
// _calib_size
// -----------------------------------------------------------------------------
/// Size of the calibration data
/// Come from the linker.
// =============================================================================
extern UINT32 _calib_size;


//  --------------------------------------------------
//  ----- Address of the calibration sector in flash.

/// Calibrated parameters buffer (used when the platform has been calibrated).
/// This buffer is in flash and can be re-burnt ONLY using CalibTool.
/// The symbol "_calib_start" is in a dedicated sector of the flash and is
/// not erased while programming the flash. It is defined by LD script.
CONST CALIB_BUFFER_T* CONST g_calibCalibSector = &_calib_start;


//  --------------------------------------------------
//  ----- Default values for baseband calibration.

///  Default calib values. Used when the platform hasn't been calibrated (the
///  status flag of "g_calibCalibSector" is checked during the calib init).
CONST CALIB_OP_INFO_T g_calibOpInfoDefault =
{
    0 /* The time of epoch. */, CALIB_METH_DEFAULT
};

/// Baseband default calibration
CONST CALIB_BB_T g_calibBbDefault =
{
    DEFAULT_CALIB_PAL_TIMES,
    {
        // ITF 0 - Receiver
        {
            DEFAULT_CALIB_AUDIO_VOC_HS_EC,
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
            DEFAULT_CALIB_AUDIO_GAINS_HS,
            DEFAULT_CALIB_AUDIO_HS_PARAMS,
        },

        // ITF 1 - Earpiece(four segment)
        {
            DEFAULT_CALIB_AUDIO_VOC_EP_EC,
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
            DEFAULT_CALIB_AUDIO_GAINS_EP,
            DEFAULT_CALIB_AUDIO_EP_PARAMS,
        },

        // ITF 2 - Loudspeaker
        {
            DEFAULT_CALIB_AUDIO_VOC_LS_EC,
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
            DEFAULT_CALIB_AUDIO_GAINS_LS,
            DEFAULT_CALIB_AUDIO_LS_PARAMS,
        },

        // ITF 3 - Bluetooth Audio(BTHS)
        {
            DEFAULT_CALIB_AUDIO_VOC_BT_EC,
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
            DEFAULT_CALIB_AUDIO_GAINS_BT,
            DEFAULT_CALIB_AUDIO_BT_PARAMS,
        },

        // ITF 4 - FM Radio
        {
            DEFAULT_CALIB_AUDIO_VOC_FM_EC,
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
            DEFAULT_CALIB_AUDIO_GAINS_FM,
            DEFAULT_CALIB_AUDIO_FM_PARAMS,
        },

        // ITF 5 - Not used yet
        {
            DEFAULT_CALIB_AUDIO_VOC_TV_EC,
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
            DEFAULT_CALIB_AUDIO_GAINS_TV,
            DEFAULT_CALIB_AUDIO_TV_PARAMS,
        },

        // ITF 6 - Earpiece(three segment)
        {
            DEFAULT_CALIB_AUDIO_VOC_EPTHREE_EC,
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
            DEFAULT_CALIB_AUDIO_GAINS_EPTHREE,
            DEFAULT_CALIB_AUDIO_EPTHREE_PARAMS,
        },

        // ITF 7 - Bluetooth Audio(BTHSNREC)
        {
            DEFAULT_CALIB_AUDIO_VOC_BTHSNREC_EC,
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
            DEFAULT_CALIB_AUDIO_GAINS_BTHSNREC,
            DEFAULT_CALIB_AUDIO_BTHSNREC_PARAMS,
        },
    },

    DEFAULT_CALIB_GPADC,
};

/// IIR default calibration
CONST CALIB_AUDIO_IIR_PARAM_T g_calibIIRDefault =
{
    // ITF 0 - Receiver
    DEFAULT_CALIB_AUDIO_IIR_PARAM_HS,

    // ITF 1 - Earpiece
    DEFAULT_CALIB_AUDIO_IIR_PARAM_EP,

    // ITF 2 - Loudspeaker
    DEFAULT_CALIB_AUDIO_IIR_PARAM_LS,

    // ITF 3 - Bluetooth Audio
    DEFAULT_CALIB_AUDIO_IIR_PARAM_BT,

    // ITF 4 - FM Radio
    DEFAULT_CALIB_AUDIO_IIR_PARAM_FM,

    // ITF 5 - TV
    DEFAULT_CALIB_AUDIO_IIR_PARAM_TV,
};

CONST CALIB_AUD_VOC_T g_calibAudioVoCDefault =
{
    {
        // ITF 0 - Receiver
        DEFAULT_CALIB_AUDIO_VOC_PARAM_HS,

        // ITF 1 - Earpiece(four segment)
        DEFAULT_CALIB_AUDIO_VOC_PARAM_EP,

        // ITF 2 - Loudspeaker
        DEFAULT_CALIB_AUDIO_VOC_PARAM_LS,

        // ITF 3 - Bluetooth Audio(BTHS)
        DEFAULT_CALIB_AUDIO_VOC_PARAM_BT,

        // ITF 4 - FM Radio
        DEFAULT_CALIB_AUDIO_VOC_PARAM_FM,

        // ITF 5 - TV
        DEFAULT_CALIB_AUDIO_VOC_PARAM_TV,

        // ITF 6 - Earpiece(three segment)
        DEFAULT_CALIB_AUDIO_VOC_PARAM_EPTHREE,

        // ITF 7 - Bluetooth Audio(BTHSNREC)
        DEFAULT_CALIB_AUDIO_VOC_PARAM_BTHSNREC,
    },
};

CONST CALIB_AUD_MUSIC_T g_calibAudioMusicDefault =
{
    {
        // ITF 0 - Receiver
        DEFAULT_CALIB_AUDIO_MUSIC_PARAM_HS,

        // ITF 1 - Earpiece
        DEFAULT_CALIB_AUDIO_MUSIC_PARAM_EP,

        // ITF 2 - Loudspeaker
        DEFAULT_CALIB_AUDIO_MUSIC_PARAM_LS,

        // ITF 3 - Bluetooth Audio
        DEFAULT_CALIB_AUDIO_MUSIC_PARAM_BT,

        // ITF 4 - FM Radio
        DEFAULT_CALIB_AUDIO_MUSIC_PARAM_FM,

        // ITF 5 - TV
        DEFAULT_CALIB_AUDIO_MUSIC_PARAM_TV,
    },
};

// =============================================================================
// g_calibCalibration
// -----------------------------------------------------------------------------
///  Global calibration structure.
///
/// Global pointers used by garnet's code to get the calibrated parameters. By
/// default, it is initialized with default parameters during calibration
/// init. And pointers used by HST to get the version number of the
/// calibration, and to find the calibration buffers.
// =============================================================================
PROTECTED CALIB_CALIBRATION_T HAL_MAP_ACCESS_LOC g_calibCalibration =
{
    CALIB_VERSION_NUMBER,
    CALIB_PARAM_INIT_ERROR,
    CALIB_CMD_NOT_ACCESSIBLE,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (CALIB_BUFFER_T*) &_calib_start,
    NULL,
    NULL,
    NULL,
    NULL,
};



//  --------------------------------------------------
//  ----- Calibration process variables.

///  We add two sets of calibration buffer in RAM to put data from HST,
///  when a calib is being done.

CALIB_OP_INFO_T  g_calibUsedOpInfo;
CALIB_XCV_T      g_calibUsedXcv;
CALIB_PA_T       g_calibUsedPa;
CALIB_SW_T       CALIB_UNCACHED_BSS  g_calibUsedSw;
CALIB_BB_T       g_calibUsedBb;
CALIB_AUDIO_IIR_PARAM_T g_calibUsedIIR;

CALIB_AUD_VOC_T                g_calibUsed_audio_voc; //
CALIB_AUD_MUSIC_T            g_calibUsed_audio_music; //


VOLATILE CALIB_OP_INFO_T CALIB_UNCACHED_BSS g_calibHstOpInfo;
VOLATILE CALIB_XCV_T     CALIB_UNCACHED_BSS g_calibHstXcv;
VOLATILE CALIB_PA_T      CALIB_UNCACHED_BSS g_calibHstPa;
VOLATILE CALIB_SW_T      CALIB_UNCACHED_BSS g_calibHstSw;
VOLATILE CALIB_BB_T      CALIB_UNCACHED_BSS g_calibHstBb;
VOLATILE CALIB_AUDIO_IIR_PARAM_T CALIB_UNCACHED_BSS g_calibHstIIR;


#ifdef CHIP_HAS_AP
PRIVATE BOOL g_calibAutoCallMode = FALSE;
#endif
#ifdef __VDS_QUICK_FLUSH__
PRIVATE BOOL g_calibDrvSuspendDisableFlag = FALSE;
#endif

// =============================================================================
//  FUNCTIONS
// =============================================================================

INLINE VOID *calib_memcpy(VOLATILE VOID *dest, CONST VOLATILE VOID *src, UINT32 n)
{
    return memcpy((VOID *)dest, (CONST VOID *)src, n);
}



//=============================================================================
// calib_GetPointers
//-----------------------------------------------------------------------------
/// Access to the calibration parameters.
///
/// @return The global pointers used by the code to access the calibrated
/// parameters. When the target's flash does not contain a flash sector,
/// the calib parameters are initialized with default parameters during
/// the calibration init. Also returns the pointers used by the remote
/// calibration tools to get the version number of the calibration and to
/// find the calibration buffers.
//=============================================================================
PUBLIC CALIB_CALIBRATION_T* calib_GetPointers(VOID)
{
    return (&g_calibCalibration);
}




//  --------------------------------------------------
//  ----- Calibration trace print.

//  Display information about the current calibration through the trace.

#define calib_Print(x)         CALIB_TRACE(_PAL | TSTDOUT, 0, "Calibration: "x)
#define calib_Print1(x, y)     CALIB_TRACE(_PAL | TSTDOUT, 0, "Calibration: "x, y)
#define calib_PrintVal(x)      CALIB_TRACE(_PAL | TSTDOUT, 0, \
        "Calibration: " #x " = %d", x)
#define calib_PrintUVal(x)     CALIB_TRACE(_PAL | TSTDOUT, 0,\
        "Calibration: " #x " = %u", x)
#define calib_PrintXVal(x)     CALIB_TRACE(_PAL | TSTDOUT, 0,\
        "Calibration: " #x " = 0x%x", x)




//=============================================================================
// calib_DaemonTracePrint
//-----------------------------------------------------------------------------
/// Display in the trace the current calibration status, used for debug.
//=============================================================================
PUBLIC VOID calib_DaemonTracePrint(VOID)
{
    //  Display the version and the parameters origin.
    if (g_calibCalibration.paramStatus == CALIB_PARAM_CALIBRATED)
    {
        calib_Print("Using calibrated parameters from flash sector.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_DEFAULT)
    {
        calib_Print("Using default calib, platform NOT calibrated.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_DEFAULT_RF_MIS)
    {
        calib_Print("Using default calib, "
                    "flash sector NOT compatible with RF chips.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_INIT_ERROR)
    {
        calib_Print("ERROR! Problem during the init of the calibration.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_RF_CALIBRATED)
    {
        calib_Print("Audio Using default calib, platform RF calibrated.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_AUDIO_CALIBRATED)
    {
        calib_Print("Audio has been calibrated, platform Rf NOT calibrated.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_AUDIO_CALIBRATED_RF_MIS)
    {
        calib_Print("Audio has been calibrated,"
                    "flash sector NOT compatible with RF chips.");
    }
    else
    {
        calib_Print("ERROR! Unknown calibration parameter used!");
    }

    calib_Print1("Calib code version = 0x%x", CALIB_VERSION_NUMBER);
    calib_Print1("Flash version tag = 0x%x", g_calibCalibSector->versionTag);
    calib_Print1("Flash sector address = 0x%x", g_calibCalibSector);
    calib_Print1("Calib method = 0x%x", g_calibCalibration.opInfo->method);

    //  Display the values of the calib parameters.
    calib_Print("Using RF chips:");
    calib_PrintXVal(g_calibCalibration.xcv->palcust.name);
    calib_PrintXVal(g_calibCalibration.pa->palcust.name);
    calib_PrintXVal(g_calibCalibration.sw->palcust.name);

    //  Display the calibration mode used.
    calib_Print("Code compiled to calibrate platforms.");
}



//  --------------------------------------------------
//  ----- Calibration mechanism and structures init.

//  Get the default calibration parameters values and set the HST calib
//  * buffers with it. This is used to init the calibration buffers and when
//  * the reset calib command is called.

//  After this, calib_UpdateBuffer() function must be called to copy the
//  * default parameters from HST buffers to used buffers.

PRIVATE VOID calib_SetRfBufferToDefault(VOID)
{
    // Default calibration values from the RF drivers.
    CONST CALIB_XCV_T *xcvDefaults = rfd_XcvCalibGetDefault();
    CONST CALIB_PA_T  *paDefaults =  rfd_PaCalibGetDefault();
    CONST CALIB_SW_T  *swDefaults =  rfd_SwCalibGetDefault();

    // Copy calib param from flash to HST RAM buffer to be able to
    // modify them from HST.
    calib_memcpy(&g_calibHstOpInfo,
                 &g_calibOpInfoDefault,
                 sizeof(g_calibHstOpInfo));

    calib_memcpy(&g_calibHstXcv,
                 xcvDefaults,
                 sizeof(g_calibHstXcv));

    calib_memcpy(&g_calibHstPa,
                 paDefaults,
                 sizeof(g_calibHstPa));

    calib_memcpy(&g_calibHstSw,
                 swDefaults,
                 sizeof(g_calibHstSw));

    calib_memcpy(&g_calibHstBb.times,
                 &g_calibBbDefault.times,
                 sizeof(g_calibHstBb.times));

    calib_memcpy(&g_calibHstBb.gpadc,
                 &g_calibBbDefault.gpadc,
                 sizeof(g_calibHstBb.gpadc));
}


PRIVATE VOID calib_SetAudioBufferToDefault(VOID)
{
    calib_memcpy(&g_calibHstBb.audio,
                 &g_calibBbDefault.audio,
                 sizeof(g_calibHstBb.audio));

    calib_memcpy(&g_calibHstIIR,
                 &g_calibIIRDefault,
                 sizeof(g_calibHstIIR));

    calib_memcpy(&g_calibUsed_audio_voc,
            &g_calibAudioVoCDefault,
            sizeof(g_calibUsed_audio_voc));
    calib_memcpy(&g_calibUsed_audio_music,
            &g_calibAudioMusicDefault,
            sizeof(g_calibUsed_audio_music));
}


/// ----- Updating the HST buffer from the used buffers (USE CALIB).
/// Copy the calib parameters from the HST RAM buffer to the used RAM
/// buffer. This function is called when the calib parameters are modified
/// by HST. Note: it does not update VoC or the bandgap cal.
PRIVATE VOID calib_UpdateRfBuffer(VOID)
{
    // Copy HST calib param to used calib data.
    calib_memcpy(&g_calibUsedOpInfo,
                 &g_calibHstOpInfo,
                 sizeof(g_calibUsedOpInfo));

    calib_memcpy(&g_calibUsedXcv,
                 &g_calibHstXcv,
                 sizeof(g_calibUsedXcv));

    calib_memcpy(&g_calibUsedPa,
                 &g_calibHstPa,
                 sizeof(g_calibUsedPa));

    calib_memcpy(&g_calibUsedSw,
                 &g_calibHstSw,
                 sizeof(g_calibUsedSw));

    calib_memcpy(&g_calibUsedBb.times,
                 &g_calibHstBb.times,
                 sizeof(g_calibUsedBb.times));

    calib_memcpy(&g_calibUsedBb.gpadc,
                 &g_calibHstBb.gpadc,
                 sizeof(g_calibUsedBb.gpadc));
}


PRIVATE VOID calib_UpdateAudioBuffer(VOID)
{
    // Copy HST calib param to used calib data.
    calib_memcpy(&g_calibUsedBb.audio,
                 &g_calibHstBb.audio,
                 sizeof(g_calibUsedBb.audio));

    calib_memcpy(&g_calibUsedIIR,
            &g_calibHstIIR,
            sizeof(g_calibUsedIIR));
}


PRIVATE VOID calib_UpdateBuffer(VOID)
{
    calib_UpdateRfBuffer();
    calib_UpdateAudioBuffer();
}


PUBLIC UINT8 calib_CheckRfCrc(VOID)
{
    UINT32 tag = g_calibCalibSector->versionTag;

    if (tag >= 0xCA1B0204)
    {
        HAL_DMA_FCS_CFG_T   fcsCtx;
        CALIB_RF_CRC_T      fcs;

        fcs                 = 0;
        fcsCtx.srcAddr      = (UINT8*)&g_calibCalibSector->versionTag;
        fcsCtx.transferSize = OFFSETOF(CALIB_BUFFER_T, bb) - OFFSETOF(CALIB_BUFFER_T, versionTag);
        fcsCtx.userHandler  = NULL;
        if (hal_DmaFcsStart(&fcsCtx) == HAL_ERR_NO)
        {
            hal_DmaReadFcs((UINT8*)&fcs);
        }
        else
        {
            sxr_ComputeFcs(fcsCtx.transferSize, fcsCtx.srcAddr, (UINT8*)&fcs);
        }
        if(fcs == g_calibCalibSector->rfCrc)
        {
            // rf calibration crc ok
            hal_HstSendEvent(0xca1bc2c0);
            return 0;
        }
        else
        {
            // rf calibration crc fail
            hal_HstSendEvent(0xca1bdead);
            return 1;
        }
    }
    else
    {
        // rf calibration has a old version
        hal_HstSendEvent(0xca1b01d0);
        return 0;
    }
}


PRIVATE UINT32 calib_GenerateRfCrc(CONST VOID *data, UINT16 len)
{
    HAL_DMA_FCS_CFG_T   fcsCtx;
    CALIB_RF_CRC_T      fcs;

    fcs                 = 0;
    fcsCtx.srcAddr      = (CONST UINT8 *)data;
    fcsCtx.transferSize = len;
    fcsCtx.userHandler  = NULL;

    if (hal_DmaFcsStart(&fcsCtx) == HAL_ERR_NO)
    {
        hal_DmaReadFcs((UINT8*)&fcs);
    }
    else
    {
        sxr_ComputeFcs(fcsCtx.transferSize, fcsCtx.srcAddr, (UINT8*)&fcs);
    }

    return fcs;
}


PRIVATE CALIB_PARAM_STATUS_T calib_InitRfBuffer(VOID)
{
    CALIB_PARAM_STATUS_T paramStatus = CALIB_PARAM_DEFAULT;
    UINT32  tag = g_calibCalibSector->versionTag;
    UINT32  mark = CALIB_MARK_MASK(tag);
    UINT8   majVer = CALIB_MAJ_MASK(tag);
#if (CALIB_CHECK_MINOR_VERSION)
    UINT8   minVer = CALIB_MIN_MASK(tag);
#endif

    //  Default calibration values from the RF drivers.
    CONST CALIB_XCV_T *xcvDefaults = rfd_XcvCalibGetDefault();
    CONST CALIB_PA_T  *paDefaults =  rfd_PaCalibGetDefault();
    CONST CALIB_SW_T  *swDefaults =  rfd_SwCalibGetDefault();

    //  Check if the platform has been calibrated.
    if ((mark == CALIB_MARK_VERSION) &&
            (majVer == CALIB_MAJ_VERSION) &&
#if (CALIB_CHECK_MINOR_VERSION)
            (minVer <= CALIB_MIN_VERSION) &&
#endif
            TRUE
       )
    {
#if (CALIB_CHECK_RF_NAME)
        // Check the RF chip names. If they are the same as the default
        // ones, don't use the flash structure.
        if (g_calibCalibSector->xcv.palcust.name == xcvDefaults->palcust.name &&
                g_calibCalibSector->pa.palcust.name ==  paDefaults->palcust.name &&
                g_calibCalibSector->sw.palcust.name ==  swDefaults->palcust.name)
        {
            paramStatus = CALIB_PARAM_RF_CALIBRATED;
        }
        else
        {
            //  Calibration parameters are present but RF chipset mismatch.
            paramStatus = CALIB_PARAM_DEFAULT_RF_MIS;
        }
#else
        paramStatus = CALIB_PARAM_RF_CALIBRATED;
#endif
    }

    //  The platform has been calibrated, get parameters from flash.
    if (CALIB_PARAM_RF_CALIBRATED == paramStatus)
    {
        // Copy calib param from flash to HST RAM buffer to be able to
        // modify them from HST.
        calib_memcpy(&g_calibHstOpInfo,
                     &g_calibCalibSector->opInfo,
                     sizeof(g_calibHstOpInfo));

        calib_memcpy(&g_calibHstXcv,
                     &g_calibCalibSector->xcv,
                     sizeof(g_calibHstXcv));

        calib_memcpy(&g_calibHstPa,
                     &g_calibCalibSector->pa,
                     sizeof(g_calibHstPa));

        calib_memcpy(&g_calibHstSw,
                     &g_calibCalibSector->sw,
                     sizeof(g_calibHstSw));

        calib_memcpy(&g_calibHstBb.times,
                     &g_calibCalibSector->bb.times,
                     sizeof(g_calibHstBb.times));

        calib_memcpy(&g_calibHstBb.gpadc,
                     &g_calibCalibSector->bb.gpadc,
                     sizeof(g_calibHstBb.gpadc));

        // GPADC structure is changed after V2.4
        if (tag == 0xCA1B0204)
        {
            calib_ConvertStructV2p4((CALIB_BB_T*)&g_calibHstBb);
        }

        // Check CRC for RF calibration data
        calib_CheckRfCrc();
    }
    //  The platform hasn't been calibrated, we get default values from
    // the different RF chip modules (transceiver, PA and switch).
    else
    {
        calib_SetRfBufferToDefault();
    }

    return paramStatus;
}

void calib_CheckCalibVersion()
{
#ifdef CHIP_DIE_8809E2
    UINT32  tag = g_calibCalibSector->versionTag;
    UINT32  mark = CALIB_MARK_MASK(tag);
    UINT8   majVer = CALIB_MAJ_MASK(tag);
    UINT8   minVer = CALIB_MIN_MASK(tag);

    if ((mark == CALIB_MARK_VERSION) &&
            (majVer == CALIB_MAJ_VERSION) &&
            (minVer < CALIB_MIN_VERSION)
       )
    {
        CALIB_ASSERT(0,"Please download calib0207 version lod or recalibration!");
    }
#endif
}
PRIVATE CALIB_PARAM_STATUS_T calib_InitAudioBuffer(VOID)
{
    CALIB_PARAM_STATUS_T paramStatus = CALIB_PARAM_DEFAULT;
    UINT32  tag = g_calibCalibSector->versionTag;
    UINT32  mark = CALIB_MARK_MASK(tag);
    UINT32  audioTag = g_calibCalibSector->audioVersionTag;
    UINT32  audioMark = CALIB_MARK_MASK(audioTag);
    UINT8   audioMajVer = CALIB_MAJ_MASK(audioTag);
#if (CALIB_CHECK_MINOR_VERSION)
    UINT8   audioMinVer = CALIB_MIN_MASK(audioTag);
#endif

    UINT32 audioExpandTag = g_calibCalibSector->audioExpand1VersionTag;

    if ((audioMark == CALIB_MARK_VERSION) &&
            (audioMajVer == CALIB_MAJ_VERSION) &&
#if (CALIB_CHECK_MINOR_VERSION)
            (audioMinVer <= CALIB_MIN_VERSION) &&
#endif
            TRUE
       )
    {
        paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
    }
    else if ((mark == CALIB_MARK_VERSION) &&
             (tag < 0xCA1B0205)
            )
    {
        // Consider audio data as calibrated even if RF names are mismatched
        paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
    }

    // FIXME: currently audioExpandTag meaning is not defined
    if (audioExpandTag == CALIB_AUDIO_VERSION_NUMBER)
        paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
    else
        paramStatus = CALIB_PARAM_DEFAULT;

    if (CALIB_PARAM_AUDIO_CALIBRATED == paramStatus)
    {
        // Copy audio calib param from flash to HST RAM buffer to be able to
        // modify them from HST.
        calib_memcpy(&g_calibHstBb.audio,
                     &g_calibCalibSector->bb.audio,
                     sizeof(g_calibHstBb.audio));

        calib_memcpy(&g_calibHstIIR,
                     &g_calibCalibSector->iirParam,
                     sizeof(g_calibHstIIR));

        calib_memcpy(&g_calibUsed_audio_voc,
                &g_calibCalibSector->audio_voc,
                sizeof(CALIB_AUD_VOC_T));
        calib_memcpy(&g_calibUsed_audio_music,
                &g_calibCalibSector->audio_music,
                sizeof(CALIB_AUD_MUSIC_T));

        // Out gain structure is changed in V2.3
        if (tag == 0xCA1B0202)
        {
            calib_ConvertStructV2p2((CALIB_BB_T*)&g_calibHstBb);
        }
        // MIC gains during a sound recording is added in V2.6
        if (tag >= 0xCA1B0202 && tag < 0xCA1B0206)
        {
            calib_ConvertStructV2p5((CALIB_BB_T*)&g_calibHstBb);
        }
    }
    else
    {
        calib_SetAudioBufferToDefault();
#ifndef DEFAULT_AUDIO_CALIB_PARAM_USED
        // The default audio calib data is calibrated by tool
        paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
#endif
    }

    return paramStatus;
}


//  --------------------------------------------------
//  ----- Calibration mechanism and structures init (USE CALIB).

// At boot time, uses the the HST parameter Ram buffer 0 and
// copy the default parameters in it.
PUBLIC VOID calib_DaemonInit(VOID)
{
    CALIB_PARAM_STATUS_T rfStatus, audioStatus;

    rfStatus = calib_InitRfBuffer();
    audioStatus = calib_InitAudioBuffer();

    g_calibCalibration.paramStatus = CALIB_PARAM_DEFAULT;
    if (CALIB_PARAM_RF_CALIBRATED == rfStatus)
    {
        if (CALIB_PARAM_AUDIO_CALIBRATED == audioStatus)
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_CALIBRATED;
        }
        else
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_RF_CALIBRATED;
        }
    }
    else if (CALIB_PARAM_DEFAULT_RF_MIS == rfStatus)
    {
        if (CALIB_PARAM_AUDIO_CALIBRATED == audioStatus)
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_AUDIO_CALIBRATED_RF_MIS;
        }
        else
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_DEFAULT_RF_MIS;
        }
    }
    else
    {
        if (CALIB_PARAM_AUDIO_CALIBRATED == audioStatus)
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
        }
        else
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_DEFAULT;
        }
    }

    //  Set the global pointers to RAM buffers.
    g_calibCalibration.opInfo =     &g_calibUsedOpInfo;
    g_calibCalibration.xcv =        &g_calibUsedXcv;
    g_calibCalibration.pa =         &g_calibUsedPa;
    g_calibCalibration.sw =         &g_calibUsedSw;
    g_calibCalibration.bb =         &g_calibUsedBb;
    g_calibCalibration.iirParam =   &g_calibUsedIIR;

    g_calibCalibration.audio_voc = &g_calibUsed_audio_voc; //0x00001CFC
    g_calibCalibration.audio_music= &g_calibUsed_audio_music; //0x00002A84


    //  Set the global pointers used by HST to RAM buffers.
    g_calibCalibration.hstOpInfo =     &g_calibHstOpInfo;
    g_calibCalibration.hstXcv =        &g_calibHstXcv;
    g_calibCalibration.hstPa =         &g_calibHstPa;
    g_calibCalibration.hstSw =         &g_calibHstSw;
    g_calibCalibration.hstBb =         &g_calibHstBb;
    g_calibCalibration.hstIIRParam =   &g_calibHstIIR;

    // Copy the calib param from HST buffers to HST buffers to
    // let HST read and modify them.
    calib_UpdateBuffer();
}



// =============================================================================
// calib_DaemonSetContext
// -----------------------------------------------------------------------------
/// Defines the context structure that HST and JCES must use.
/// @param ctx Pointer to the context to use.
// =============================================================================
PUBLIC VOID calib_DaemonSetContext(VOID* ctx)
{
    g_calibCalibration.stubCtx = ctx;
}
PUBLIC VOID calib_DaemonSetNsftContext(VOID* ctx)
{
    g_calibCalibration.stubNsftCtx = ctx;
}
//  --------------------------------------------------
//  ----- Calibration command execution.
PRIVATE VOID calib_PrepareRfData(CALIB_BUFFER_T *buffer)
{
    CALIB_VERSION_TAG_T tagConfigured = CALIB_VERSION_NUMBER;

    //  Write the RF calib data.
    calib_memcpy(&buffer->opInfo,
                 g_calibCalibration.opInfo,
                 sizeof(buffer->opInfo));

    calib_memcpy(&buffer->xcv,
                 g_calibCalibration.xcv,
                 sizeof(buffer->xcv));

    calib_memcpy(&buffer->pa,
                 g_calibCalibration.pa,
                 sizeof(buffer->pa));

    calib_memcpy(&buffer->sw,
                 g_calibCalibration.sw,
                 sizeof(buffer->sw));

    calib_memcpy(&buffer->bb.times,
                 &g_calibCalibration.bb->times,
                 sizeof(buffer->bb.times));

    calib_memcpy(&buffer->bb.gpadc,
                 &g_calibCalibration.bb->gpadc,
                 sizeof(buffer->bb.gpadc));

    //  Write the tag saying that the Platform has been calibrated.
    calib_memcpy(&buffer->versionTag,
                 &tagConfigured,
                 sizeof(buffer->versionTag));

    // Generate and write the CRC value for RF calibation data
    UINT32 rfCrc = calib_GenerateRfCrc(&buffer->versionTag,
                                       OFFSETOF(CALIB_BUFFER_T, bb) - OFFSETOF(CALIB_BUFFER_T, versionTag));
    calib_memcpy(&buffer->rfCrc,
                 &rfCrc,
                 sizeof(buffer->rfCrc));
}


PRIVATE VOID calib_PrepareAudioData(CALIB_BUFFER_T *buffer)
{
    CALIB_VERSION_TAG_T tagConfigured = CALIB_VERSION_NUMBER;
    CALIB_VERSION_TAG_T audioTagConfigured = CALIB_AUDIO_VERSION_NUMBER;

    // Write the audio calib data
    calib_memcpy(&buffer->bb.audio,
                 &g_calibCalibration.bb->audio,
                 sizeof(buffer->bb.audio));

    calib_memcpy(&buffer->iirParam,
                 g_calibCalibration.iirParam,
                 sizeof(buffer->iirParam));

    calib_memcpy(&buffer->audio_voc,
                 g_calibCalibration.audio_voc,
                 sizeof(buffer->audio_voc));
    calib_memcpy(&buffer->audio_music,
                 g_calibCalibration.audio_music,
                 sizeof(buffer->audio_music));
    // FIXME: currently audioExpandTag meaning is not defined
    calib_memcpy(&buffer->audioExpand1VersionTag,
                 &audioTagConfigured,
                 sizeof(buffer->audioExpand1VersionTag));

    //  Write the tag saying that the audio data has been calibrated.
    calib_memcpy(&buffer->audioVersionTag,
                 &tagConfigured,
                 sizeof(buffer->audioVersionTag));
}


/// Function used to program the flash calibration sector.
/// Hyp: MEMD Flash Driver opened before hand.
PRIVATE BOOL burn(CONST VOID* fshPptr, CONST VOID* srcPtr, UINT32 size)
{
    if (size == 0)
    {
        return TRUE;
    }

#ifdef CHIP_HAS_AP

    memcpy((UINT8*)HAL_SYS_GET_UNCACHED_ADDR(fshPptr), srcPtr, size);

#else // !CHIP_HAS_AP

    MEMD_ERR_T flashError;
    UINT32 len, addrFsh;

    //  Find the address local in the flash.
    addrFsh = (UINT32)fshPptr - (UINT32)memd_FlashGetGlobalAddress(0);
    addrFsh &= 0x0fffffff;

    // Write calib flash sector.
    // This function is in RAM, so it can be executed no matter
    // which sector is accessed to burn the calibration sector.
    // Moreover, this code is executed during the Fint interrupt,
    // which has a very high priority, so no other code (That could
    // come from the same bank) is executed.
    if(g_Calib_OnSite)
    {
#ifdef __VDS_QUICK_FLUSH__
        flashError = memd_CacheWrite((UINT8*)addrFsh, size, &len, (UINT8*)srcPtr);
#else
        flashError = memd_FlashWrite((UINT8*)addrFsh, size, &len, (CONST UINT8*)srcPtr);
#endif
    }
    else
        flashError = memd_FlashWrite((UINT8*)addrFsh, size, &len, (CONST UINT8*)srcPtr);
    //  Check flash writting.
    if ((flashError != MEMD_ERR_NO) || (len != size))
    {
        //  Here we are screwed-up. Just return false.
        calib_PrintVal(flashError);
        return FALSE;
    }

#endif // !CHIP_HAS_AP

    return TRUE;
}


PRIVATE BOOL calib_BurnBuffer(CONST VOID *buffer)
{
    CONST CALIB_BUFFER_T *calibBuffer = buffer;
    BOOL ok = TRUE;

    ok &= burn(&g_calibCalibSector->opInfo,
               &calibBuffer->opInfo,
               ((UINT32)&g_calibCalibSector->audioVersionTag -
                (UINT32)&g_calibCalibSector->opInfo));

    ok &= burn(&g_calibCalibSector->iirParam,
               &calibBuffer->iirParam,
               sizeof(g_calibCalibSector->iirParam));

    // FIXME: currently audioExpandTag meaning is not defined
    ok &= burn(&g_calibCalibSector->audioExpand1VersionTag,
               &calibBuffer->audioExpand1VersionTag,
               sizeof(g_calibCalibSector->audioExpand1VersionTag));
    ok &= burn(&g_calibCalibSector->audio_voc,
               &calibBuffer->audio_voc,
               sizeof(g_calibCalibSector->audio_voc));
    ok &= burn(&g_calibCalibSector->audio_music,
               &calibBuffer->audio_music,
               sizeof(g_calibCalibSector->audio_music));

    if (ok)
    {
        ok &= burn(&g_calibCalibSector->versionTag,
                   &calibBuffer->versionTag,
                   sizeof(g_calibCalibSector->versionTag));
    }

    if (ok)
    {
        UINT32 rfCrc = calib_GenerateRfCrc(&g_calibCalibSector->versionTag,
                                           OFFSETOF(CALIB_BUFFER_T, bb) - OFFSETOF(CALIB_BUFFER_T, versionTag));
        ok &= burn(&g_calibCalibSector->rfCrc,
                   &rfCrc,
                   sizeof(g_calibCalibSector->rfCrc));
    }

    if (ok)
    {
        ok &= burn(&g_calibCalibSector->audioVersionTag,
                   &calibBuffer->audioVersionTag,
                   sizeof(g_calibCalibSector->audioVersionTag));
    }

    return ok;
}


PRIVATE BOOL calib_BurnCurUsedData(VOID)
{
    CALIB_VERSION_TAG_T tagConfigured = CALIB_VERSION_NUMBER;
    CALIB_BUFFER_T *calibBuffer = NULL;
    BOOL ok = TRUE;
    CALIB_VERSION_TAG_T audioTagConfigured = CALIB_AUDIO_VERSION_NUMBER;

    if(g_Calib_OnSite)
    {
        calibBuffer = (CALIB_BUFFER_T*)sxr_Malloc(sizeof(*g_calibCalibSector));
        calibBuffer->versionTag = CALIB_VERSION_NUMBER;

        memcpy(&calibBuffer->opInfo,g_calibCalibration.opInfo,sizeof(g_calibCalibSector->opInfo));
        memcpy(&calibBuffer->xcv,g_calibCalibration.xcv,sizeof(g_calibCalibSector->xcv));
        memcpy(&calibBuffer->pa,g_calibCalibration.pa,sizeof(g_calibCalibSector->pa));
        memcpy(&calibBuffer->sw,g_calibCalibration.sw,sizeof(g_calibCalibSector->sw));
    }
    //  Write the RF calib data.
    ok &= burn(&g_calibCalibSector->opInfo,
               g_calibCalibration.opInfo,
               sizeof(g_calibCalibSector->opInfo));

    ok &= burn(&g_calibCalibSector->xcv,
               g_calibCalibration.xcv,
               sizeof(g_calibCalibSector->xcv));

    ok &= burn(&g_calibCalibSector->pa,
               g_calibCalibration.pa,
               sizeof(g_calibCalibSector->pa));

    ok &= burn(&g_calibCalibSector->sw,
               g_calibCalibration.sw,
               sizeof(g_calibCalibSector->sw));

    calib_Print1("write to calibCalibSector bb: 0x%x", &g_calibCalibSector->bb);
    ok &= burn(&g_calibCalibSector->bb,
               g_calibCalibration.bb,
               sizeof(g_calibCalibSector->bb));

    ok &= burn(&g_calibCalibSector->iirParam,
               g_calibCalibration.iirParam,
               sizeof(g_calibCalibSector->iirParam));

    calib_Print1("write to calibCalibSector audio_voc: 0x%x", &g_calibCalibSector->audio_voc);
    calib_Print1("write to calibCalibSector audio_music: 0x%x", &g_calibCalibSector->audio_music);
    // FIXME: currently audioExpandTag meaning is not defined
    ok &= burn(&g_calibCalibSector->audioExpand1VersionTag,
               &audioTagConfigured,
               sizeof(g_calibCalibSector->audioExpand1VersionTag));
    ok &= burn(&g_calibCalibSector->audio_voc,
               g_calibCalibration.audio_voc,
               sizeof(g_calibCalibSector->audio_voc));
    ok &= burn(&g_calibCalibSector->audio_music,
               g_calibCalibration.audio_music,
               sizeof(g_calibCalibSector->audio_music));

    if (ok)
    {
        //  Write the tag saying that the Platform has been calibrated.
        ok &= burn(&g_calibCalibSector->versionTag,
                   &tagConfigured,
                   sizeof(g_calibCalibSector->versionTag));
    }
    if (ok)
    {
        // Generate and write the CRC value for RF calibation data
        UINT32 rfCrc = 0;
        if(g_Calib_OnSite)
        {
            rfCrc = calib_GenerateRfCrc(&calibBuffer->versionTag,
                                        OFFSETOF(CALIB_BUFFER_T, bb) - OFFSETOF(CALIB_BUFFER_T, versionTag));
        }
        else
        {
            rfCrc = calib_GenerateRfCrc(&g_calibCalibSector->versionTag,
                                        OFFSETOF(CALIB_BUFFER_T, bb) - OFFSETOF(CALIB_BUFFER_T, versionTag));
        }

        ok &= burn(&g_calibCalibSector->rfCrc,
                   &rfCrc,
                   sizeof(g_calibCalibSector->rfCrc));
    }

    if (ok)
    {
        //  Write the tag saying that the audio data has been calibrated.
        calib_Print1("write to calibCalibSector audioVersionTag: 0x%x", &g_calibCalibSector->audioVersionTag);
        ok &= burn(&g_calibCalibSector->audioVersionTag,
                   &tagConfigured,
                   sizeof(g_calibCalibSector->audioVersionTag));
    }
    if(g_Calib_OnSite)
    {
        if(calibBuffer)
        {
            sxr_Free(calibBuffer);
            calibBuffer = NULL;
        }
    }
    return ok;
}

PRIVATE BOOL calib_BurnCurUsedAudioData(CALIB_VERSION_TAG_T tag)
{
    CALIB_VERSION_TAG_T tagConfigured = CALIB_VERSION_NUMBER;
    BOOL ok = TRUE;
    CALIB_VERSION_TAG_T audioTagConfigured = CALIB_AUDIO_VERSION_NUMBER;

    //  Write the RF calib data.
    ok &= burn(&g_calibCalibSector->opInfo,
               g_calibCalibration.opInfo,
               sizeof(g_calibCalibSector->opInfo));

    ok &= burn(&g_calibCalibSector->xcv,
               g_calibCalibration.xcv,
               sizeof(g_calibCalibSector->xcv));

    ok &= burn(&g_calibCalibSector->pa,
               g_calibCalibration.pa,
               sizeof(g_calibCalibSector->pa));

    ok &= burn(&g_calibCalibSector->sw,
               g_calibCalibration.sw,
               sizeof(g_calibCalibSector->sw));

    calib_Print1("write to calibCalibSector bb: 0x%x", &g_calibCalibSector->bb);
    ok &= burn(&g_calibCalibSector->bb,
               g_calibCalibration.bb,
               sizeof(g_calibCalibSector->bb));

    ok &= burn(&g_calibCalibSector->iirParam,
               g_calibCalibration.iirParam,
               sizeof(g_calibCalibSector->iirParam));

    calib_Print1("write to calibCalibSector audio_voc: 0x%x", &g_calibCalibSector->audio_voc);
    calib_Print1("write to calibCalibSector audio_music: 0x%x", &g_calibCalibSector->audio_music);
    // FIXME: currently audioExpandTag meaning is not defined
    ok &= burn(&g_calibCalibSector->audioExpand1VersionTag,
               &audioTagConfigured,
               sizeof(g_calibCalibSector->audioExpand1VersionTag));
    ok &= burn(&g_calibCalibSector->audio_voc,
               g_calibCalibration.audio_voc,
               sizeof(g_calibCalibSector->audio_voc));
    ok &= burn(&g_calibCalibSector->audio_music,
               g_calibCalibration.audio_music,
               sizeof(g_calibCalibSector->audio_music));

    if (ok)
    {
        //  Write the tag saying that the Platform has been calibrated.
        ok &= burn(&g_calibCalibSector->versionTag,
                   &tag,
                   sizeof(g_calibCalibSector->versionTag));
    }

    if (ok)
    {
        // Generate and write the CRC value for RF calibation data
        UINT32 rfCrc = calib_GenerateRfCrc(&g_calibCalibSector->versionTag,
                                           OFFSETOF(CALIB_BUFFER_T, bb) - OFFSETOF(CALIB_BUFFER_T, versionTag));
        ok &= burn(&g_calibCalibSector->rfCrc,
                   &rfCrc,
                   sizeof(g_calibCalibSector->rfCrc));
    }

    if (ok)
    {
        //  Write the tag saying that the audio data has been calibrated.
        calib_Print1("write to calibCalibSector audioVersionTag: 0x%x", &g_calibCalibSector->audioVersionTag);
        ok &= burn(&g_calibCalibSector->audioVersionTag,
                   &tagConfigured,
                   sizeof(g_calibCalibSector->audioVersionTag));
    }

    return ok;
}

PUBLIC BOOL calib_BurnFlash(VOID)
{
    UINT32 calibSectorStart;
    UINT32 calibSectorEnd;
    CALIB_VERSION_TAG_T tag = g_calibCalibSector->versionTag;

#ifdef CHIP_HAS_AP

    calibSectorStart = HAL_SYS_GET_UNCACHED_ADDR(g_calibCalibSector);
    calibSectorEnd = HAL_SYS_GET_UNCACHED_ADDR(&_factory_start);
    memset((UINT8*)calibSectorStart, 0xFF, calibSectorEnd-calibSectorStart);

#else // !CHIP_HAS_AP

    // The dst_ptr is a local flash address, this is UINT32.
    MEMD_ERR_T flashError;

    // Erase calib flash sector.
    calibSectorStart = HAL_SYS_GET_UNCACHED_ADDR(g_calibCalibSector) -
                       HAL_SYS_GET_UNCACHED_ADDR(memd_FlashGetGlobalAddress(0));

    calibSectorEnd = HAL_SYS_GET_UNCACHED_ADDR(&_factory_start) -
                     HAL_SYS_GET_UNCACHED_ADDR(memd_FlashGetGlobalAddress(0));

#ifdef __VDS_QUICK_FLUSH__
    if(memd_SuspendIsEnable())
    {
        DRV_SuspendDisable();
        calib_SetDrvSuspendDisableFlag(TRUE);
    }
#endif
    hal_SysEnterCriticalSection();
    flashError = memd_FlashErase((UINT8*)calibSectorStart, (UINT8*)calibSectorEnd);

    if (flashError != MEMD_ERR_NO)
    {
        // In case of error, just say it to HST.
        calib_Print("ERROR! Calib flash sector erase problem!");
        calib_PrintVal(flashError);
        return FALSE;
    }
    memd_Flash_CalibWriteFlashFlag(TRUE);
#endif
    if (!calib_BurnCurUsedAudioData(tag))
    {
        // TODO: we should say it to HST in case of error
        calib_Print("ERROR! Calib flash sector burn problem!");
#ifndef CHIP_HAS_AP
        memd_Flash_CalibWriteFlashFlag(FALSE);
#endif
        return FALSE;
    }

#ifdef CHIP_HAS_AP
    hal_ApCommSetFactoryUpdateCmd(HAL_AP_COMM_FACT_UPDATE_CALIB);
#else
    memd_Flash_CalibWriteFlashFlag(FALSE);
#endif

    return TRUE;
}

PUBLIC VOID calib_UpdateBufferData(CALIB_BUFFER_T *buffer)
{
    calib_memcpy(g_calibCalibration.audio_voc,
                 &buffer->audio_voc,
                 sizeof(CALIB_AUD_VOC_T));
    calib_memcpy(g_calibCalibration.audio_music,
                 &buffer->audio_music,
                 sizeof(CALIB_AUD_MUSIC_T));
    calib_memcpy(&g_calibCalibration.bb->audio,
                 &buffer->bb.audio,
                 sizeof(buffer->bb.audio));
    calib_memcpy(g_calibCalibration.iirParam,
                 &buffer->iirParam,
                 sizeof(CALIB_AUDIO_IIR_PARAM_T));
}


//  Function used to update the Platform's used calibration buffers when the
//  user modifies them with HST. It also executes calib cmd.
PUBLIC VOID calib_DaemonProcess(VOID)
{
    // Check out if some calibration update has to be done.
    CALIB_COMMAND_T tag = *((CALIB_COMMAND_T *)HAL_SYS_GET_UNCACHED_ADDR(
                                (UINT32)(&g_calibCalibration.command)));
    CALIB_BUFFER_T *burnBuffer = NULL;

    // An error is pending or there is no command to execute.
    if (CALIB_CMD_NOT_ACCESSIBLE == tag || CALIB_CMD_DONE == tag ||
            CALIB_CMD_FLASH_ERROR == tag)
    {
        goto _exit;
    }

    // Debug print.
    calib_Print("A calib command has been found. Executing...");

    // --- Calibration parameters must be updated. ---
    if (CALIB_CMD_UPDATE == tag)
    {
        //  Copy the calib param from HST buffers to HST buffers to
        //  let HST read and modify them.
        calib_UpdateBuffer();

        // Update RFD calibrations
        rfd_XcvCalibUpdateValues();
        rfd_SwCalibUpdateValues();
        rfd_PaCalibUpdateValues();

        calib_Print("Calibration parameters updated.");
    }

    // --- Calibration parameters must be reset to default values. ---
    if (CALIB_CMD_RF_RESET == tag ||
            CALIB_CMD_RESET == tag)
    {
        // Set the HST calib buffers to the default values.
        calib_SetRfBufferToDefault();

        // Copy the calib param from HST buffers to used buffers.
        calib_UpdateRfBuffer();

        // Call each module to ask him to reset its calib param,
        // if needed (i.e. for custom parameters like CDAC, HAL_A, etc.).
        rfd_XcvCalibResetValues();
        rfd_PaCalibResetValues();
        rfd_SwCalibResetValues();

        calib_Print("RF calib parameters reset.");
    }

    if (CALIB_CMD_AUDIO_RESET == tag ||
            CALIB_CMD_RESET == tag)
    {
        // Set the HST calib buffers to the default values.
        calib_SetAudioBufferToDefault();

        // Copy the calib param from HST buffers to used buffers.
        calib_UpdateAudioBuffer();

        calib_Print("Audio calib parameters reset.");
    }

    // --- The flash must be erased! ---
    if (CALIB_CMD_FLASH_ERASE == tag ||
            CALIB_CMD_RF_FLASH_BURN == tag ||
            CALIB_CMD_AUDIO_FLASH_BURN == tag ||
            CALIB_CMD_FLASH_BURN == tag)
    {
        UINT32 calibSectorStart;
        UINT32 calibSectorEnd;

        if (CALIB_CMD_RF_FLASH_BURN == tag ||
                CALIB_CMD_AUDIO_FLASH_BURN == tag)
        {
            burnBuffer = (CALIB_BUFFER_T*)sxr_Malloc(sizeof(*g_calibCalibSector));
            memcpy(burnBuffer, g_calibCalibSector, sizeof(*g_calibCalibSector));
        }

#ifdef CHIP_HAS_AP

        if (CALIB_CMD_FLASH_ERASE == tag)
        {
            calibSectorStart = HAL_SYS_GET_UNCACHED_ADDR(g_calibCalibSector);
            calibSectorEnd = HAL_SYS_GET_UNCACHED_ADDR(&_factory_start);
            memset((UINT8*)calibSectorStart, 0xFF, calibSectorEnd-calibSectorStart);
        }

#else // !CHIP_HAS_AP

        //  The dst_ptr is a local flash address, this is UINT32.
        MEMD_ERR_T flashError = 0;

        //  Erase calib flash sector.
        calibSectorStart = HAL_SYS_GET_UNCACHED_ADDR(g_calibCalibSector) -
                           HAL_SYS_GET_UNCACHED_ADDR(memd_FlashGetGlobalAddress(0));

        calibSectorEnd = HAL_SYS_GET_UNCACHED_ADDR(&_factory_start) -
                         HAL_SYS_GET_UNCACHED_ADDR(memd_FlashGetGlobalAddress(0));

        // This function is in RAM, so it can be executed no matter
        // which sector is accessed to burn the calibration sector.
        // Moreover, this code is executed during the Fint interrupt,
        // which has a very high priority, so no other code (That could
        // come from the same bank) is executed.

        if(g_Calib_OnSite)
        {
#ifdef __VDS_QUICK_FLUSH__
            extern MEMD_FLASH_LAYOUT_T g_memdFlashLayout;
            for(int i = 0; i < (calibSectorEnd - calibSectorStart)/g_memdFlashLayout.bankLayout->sectorLayoutTable[1][1]; i++)
            {
                flashError = memd_CacheErase((UINT8*)calibSectorStart + i*g_memdFlashLayout.bankLayout->sectorLayoutTable[1][1],
                                             (UINT8*)calibSectorStart + (i+1)*g_memdFlashLayout.bankLayout->sectorLayoutTable[1][1],0);
            }
#else
            flashError = memd_FlashErase((UINT8*)calibSectorStart,
                                         (UINT8*)calibSectorEnd);
#endif
        }
        else
        {
            flashError = memd_FlashErase((UINT8*)calibSectorStart,
                                         (UINT8*)calibSectorEnd);
        }
        if (flashError != MEMD_ERR_NO)
        {
            // In case of error, just say it to HST.
            calib_Print("ERROR! Calib flash sector erase problem!");
            calib_PrintVal(flashError);
            g_calibCalibration.command = CALIB_CMD_FLASH_ERROR;
            goto _exit;
        }

#endif // !CHIP_HAS_AP

        // Say that the flash has been erased.
        calib_Print("The calib flash sector has been erased successfully!");
    }

    //  --- The flash must be burnt! ---
    if (CALIB_CMD_RF_FLASH_BURN == tag ||
            CALIB_CMD_AUDIO_FLASH_BURN == tag)
    {
        if (CALIB_CMD_RF_FLASH_BURN == tag)
        {
            calib_Print("Prepare RF calib data.");
            calib_PrepareRfData(burnBuffer);
        }

        if (CALIB_CMD_AUDIO_FLASH_BURN == tag ||
#ifndef DEFAULT_AUDIO_CALIB_PARAM_USED
                // The default audio calib data is calibrated by tool
                CALIB_CMD_RF_FLASH_BURN == tag ||
#endif
                FALSE
           )
        {
            calib_Print("Prepare audio calib data.");
            calib_PrepareAudioData(burnBuffer);
        }

        //  The calib sector in flash has already been erased.
        if (!calib_BurnBuffer(burnBuffer))
        {
            // In case of error, just say it to HST.
            calib_Print("ERROR! Calib flash sector burn problem!");
            g_calibCalibration.command = CALIB_CMD_FLASH_ERROR;
            goto _exit;
        }

        calib_Print("The calib flash sector has been burnt successfully!");
    }

    if (CALIB_CMD_FLASH_BURN == tag)
    {
        if (!calib_BurnCurUsedData())
        {
            // In case of error, just say it to HST.
            calib_Print("ERROR! Calib flash sector burn problem!");
            g_calibCalibration.command = CALIB_CMD_FLASH_ERROR;
            goto _exit;
        }

        calib_Print("The calib flash sector has been burnt successfully!");
    }

#ifdef CHIP_HAS_AP
    if (CALIB_CMD_FLASH_ERASE == tag ||
            CALIB_CMD_RF_FLASH_BURN == tag ||
            CALIB_CMD_AUDIO_FLASH_BURN == tag ||
            CALIB_CMD_FLASH_BURN == tag ||
            CALIB_CMD_CFP_BURN == tag)
    {
        if (pal_GetCalibProcess())
        {
            // In calib mode or autocall mode
            // Disable calib process
            pal_SetCalibProcess(FALSE);
            // Tell AP the calibration has been done
            syscmds_SendCalibDoneMsg();
            // Need to wait for the response from AP
            calib_Print("Notify AP to do flash operation!");
        }
        else
        {
            // In normal mode
            // Application is trying to update calibation data by calib_DaemonUsrDataProcess()
            hal_ApCommSetFactoryUpdateCmd(HAL_AP_COMM_FACT_UPDATE_CALIB);
            g_calibCalibration.command = CALIB_CMD_DONE;

        }
    }
    else
#endif
    {
        // --- Calibration is done ---
        // Inform HST that the command has been processed
        g_calibCalibration.command = CALIB_CMD_DONE;
    }

    if(g_Calib_OnSite)
    {
#ifdef __VDS_QUICK_FLUSH__
        UINT32 cri_status;
        cri_status = hal_SysEnterCriticalSection();
        hal_SysExitCriticalSection(cri_status);
        VDS_CacheSendFlushEvent();
#endif
    }
_exit:
    if (burnBuffer)
    {
        sxr_Free(burnBuffer);
        burnBuffer = NULL;
    }

    return;
}


// =============================================================================
// calib_DaemonUsrDataProcess
// -----------------------------------------------------------------------------
/// Apply and burn HST calibration buffer.
/// @return TRUE if success, and FALSE otherwise.
// =============================================================================
PUBLIC BOOL calib_DaemonUsrDataProcess(VOID)
{
    UINT32 scStatus;
    BOOL result;
    CALIB_COMMAND_T cmd = CALIB_CMD_FLASH_BURN;

    calib_UpdateBuffer();

    scStatus = hal_SysEnterCriticalSection();

#ifdef CHIP_HAS_AP
    if (!g_calibAutoCallMode)
#endif
    {
        pal_SetCalibProcess(FALSE);
    }

    g_calibCalibration.command = cmd;
    *((CALIB_COMMAND_T *)HAL_SYS_GET_UNCACHED_ADDR(
          (UINT32)(&g_calibCalibration.command))) = cmd;

    calib_DaemonProcess();

    hal_SysExitCriticalSection(scStatus);

#ifdef CHIP_HAS_AP
    if (g_calibAutoCallMode)
    {
        while (g_calibCalibration.command == cmd)
        {
            sxr_Sleep(20 MS_WAITING);
        }
    }
#endif

    result = (g_calibCalibration.command == CALIB_CMD_DONE);

#ifdef CHIP_HAS_AP
    if (!g_calibAutoCallMode)
#endif
    {
        pal_SetCalibProcess(TRUE);
    }

    return result;
}


// =============================================================================
// calib_GetRfCalibStatus
// -----------------------------------------------------------------------------
/// Get the status of RF calibration data.
/// @return 0 if calibrated with good CRC, 1 if calibrated with bad CRC,
///         2 if not calibrated.
// =============================================================================
PUBLIC UINT8 calib_GetRfCalibStatus(VOID)
{
    if (g_calibCalibration.paramStatus == CALIB_PARAM_RF_CALIBRATED ||
            g_calibCalibration.paramStatus == CALIB_PARAM_CALIBRATED)
    {
        return calib_CheckRfCrc();
    }

    // RF not calibrated
    return 2;
}


// =============================================================================
// calib_GetAudioCalibStatus
// -----------------------------------------------------------------------------
/// Get the status of audio calibration data.
/// @return 0 if calibrated, 2 if not calibrated.
// =============================================================================
PUBLIC UINT8 calib_GetAudioCalibStatus(VOID)
{
    if (g_calibCalibration.paramStatus == CALIB_PARAM_AUDIO_CALIBRATED ||
            g_calibCalibration.paramStatus == CALIB_PARAM_CALIBRATED)
    {
        return 0;
    }

    // Audio not calibrated
    return 2;
}
#ifdef __VDS_QUICK_FLUSH__
PUBLIC VOID calib_GetStationPassFlag()
{
    UINT16 passflag=0;
    UINT16 performflag=0;
    UINT8* stationName = NULL;
#define STATIONNAMELEN   12
    tgt_SyncGetStationPassed((UINT16*)&passflag);
    tgt_SyncGetStationPerformed((UINT16*)&performflag);
    stationName = (UINT8*)sxr_Malloc(15*STATIONNAMELEN+4);
    for(int i = 0; i<15; i++)
    {
        memset(&stationName[i*STATIONNAMELEN],0,STATIONNAMELEN);
        tgt_SyncGetStationName(i,&stationName[i*STATIONNAMELEN]);
    }
    stationName[15*STATIONNAMELEN] = (passflag>> 8)&0xff;
    stationName[15*STATIONNAMELEN+1] = (passflag)&0xff;
    stationName[15*STATIONNAMELEN+2] = (performflag>> 8)&0xff;
    stationName[15*STATIONNAMELEN+3] = (performflag)&0xff;
    #if(XCPU_CACHE_MODE_WRITE_BACK==1)
    hal_DcacheFlushAll(TRUE);
    #endif
    g_calibCalibration.sw->param[13] = ((UINT32)stationName)&0x7fffffff;
}
PUBLIC VOID calib_SetStationFlag()
{
    UINT32 flag =(g_calibCalibration.hstSw->param[14] >> 18)&0x3f;
    if(flag&0x3f)
    {
        switch(flag & 0x2a)
        {
            case 0x2:
                tgt_SyncSetStationPerformedAndPassedByName("CALIB", flag&0x2, flag&0x1);
                break;
            case 0x8:
                tgt_SyncSetStationPerformedAndPassedByName("ANNTEST", flag&0x8, flag&0x4);
                break;
            case 0x20:
                tgt_SyncSetStationPerformedAndPassedByName("NSTEST", flag&0x20, flag&0x10);
                break;
        }
        g_calibCalibration.hstSw->param[14] &= 0x8003ffff;
    }
}
#endif
#ifdef CHIP_HAS_AP
// =============================================================================
// calib_DaemonSetAutoCallMode
// -----------------------------------------------------------------------------
/// Tell calibration daemon process whether current mode is autocall.
// =============================================================================
PUBLIC VOID calib_DaemonSetAutoCallMode(BOOL autocall)
{
    g_calibAutoCallMode = autocall;
}


// =============================================================================
// calib_DaemonHandleApResponse
// -----------------------------------------------------------------------------
/// Receive the flash burning result from AP bootloader.
// =============================================================================
PUBLIC VOID calib_DaemonHandleApResponse(BOOL result)
{
    CALIB_COMMAND_T POSSIBLY_UNUSED tag =
        *((CALIB_COMMAND_T *)HAL_SYS_GET_UNCACHED_ADDR(
              (UINT32)(&g_calibCalibration.command)));
    //  --- Calibration is done ---
    // Inform HST that the command has been processed
    if (result)
    {
        calib_Print1("AP has finished the flash operation successfully: 0x%08x", tag);
        g_calibCalibration.command = CALIB_CMD_DONE;
    }
    else
    {
        calib_Print1("ERROR! AP failed to do the flash operation: 0x%08x", tag);
        g_calibCalibration.command = CALIB_CMD_FLASH_ERROR;
    }

    // Re-enable calib process
    pal_SetCalibProcess(TRUE);
}
#endif

#ifdef __VDS_QUICK_FLUSH__
PUBLIC VOID calib_SetDrvSuspendDisableFlag(BOOL flag)
{
    g_calibDrvSuspendDisableFlag = flag;
}

PUBLIC BOOL calib_GetDrvSuspendDisableFlag(VOID)
{
    return g_calibDrvSuspendDisableFlag;
}
#endif
